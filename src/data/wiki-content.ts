export interface WikiArticle {
  slug: string;
  title: string;
  section: string;
  content: string;
  codeBlocks?: { language: string; code: string; title?: string }[];
}

export interface WikiSection {
  name: string;
  articles: WikiArticle[];
}

export const wikiContent: WikiSection[] = [
  {
    name: "التحول الكبير (The Vibe Shift)",
    articles: [
      {
        slug: "what-is-vibe-coding",
        title: "ما هي البرمجة بالإحساس؟",
        section: "التحول الكبير",
        content: `
# ما هي البرمجة بالإحساس؟ (Vibe Coding)

**البرمجة بالإحساس** هي فن بناء البرمجيات من خلال التعاون مع الذكاء الاصطناعي، والثقة في حدسك، والشحن السريع (Shipping). لا يتعلق الأمر بحفظ كل واجهة برمجة تطبيقات (API) أو فهم كل سطر من الأكواد الروتينية (Boilerplate)—بل يتعلق بالدخول في **حالة تدفق إبداعي** حيث تقوم أنت وزميلك المبرمج (الذكاء الاصطناعي) بالابتكار معاً.

## الفلسفة

البرمجة التقليدية تشبه نحت تمثال بإزميل—منهجية، دقيقة، وبطيئة. أما البرمجة بالإحساس فهي مثل التشكيل بصلصال ذكي يعيد تشكيل نفسه بناءً على رؤيتك. أنت تصف ما تريد، والذكاء الاصطناعي يقترح الحلول، وأنتما تكرران العملية معاً.

### المبادئ الأساسية

1. **الحدس فوق الحفظ** — لا تضيع طاقتك الذهنية في حفظ القواعد النحوية للكود. ركز على *ماذا* تريد أن تبني.

2. **هندسة البرومبت هي النحو الجديد** — قدرتك على التواصل مع الذكاء الاصطناعي هي ما يحدد جودة مخرجاتك.

3. **اشحن بسرعة، كرر أسرع** — "المثالي" هو عدو "المشحون". اجعل الشيء يعمل أولاً، ثم قم بتحسينه.

4. **تقبل المجهول** — لست بحاجة لفهم كل سطر. ثق في العملية، وتحقق من المخرجات.

## عقلية مبرمج الإحساس

مبرمج الإحساس ليس مبرمجاً أسوأ—إنه **نوع مختلف من المبرمجين**. بدلاً من منافسة الذكاء الاصطناعي في كتابة الكود الروتيني، فإنه يستغل الذكاء الاصطناعي لتلك المهام ويركز على:

- **قرارات المعمارية** — كيف يجب أن يبدو هذا النظام؟
- **تجربة المستخدم** — كيف يجب أن يكون شعور استخدام هذا المنتج؟
- **منطق العمل** — ما هي المشكلة التي نحلها بالفعل؟
- **مراقبة الجودة** — هل هذا يعمل حقاً؟

## متى تستخدمها؟

تتألق البرمجة بالإحساس في:
- بناء النماذج الأولية السريعة (Prototyping)
- تعلم أطر عمل جديدة
- بناء المنتجات الأولية (MVPs)
- استكشاف الإمكانيات التقنية
- المشاريع الجانبية والهاكاثونات

## حالة التدفق (Flow State)

عندما تكون "في المود"، تشعر البرمجة بالإحساس وكأنها محادثة مع زميل عبقري لا يتعب أبداً، ولا يحكم على أسئلتك، ويمكنه كتابة الكود بسرعة التفكير. هذا هو "الفايب".
        `,
      },
      {
        slug: "the-vibe-stack",
        title: "حزمة الإحساس (The Vibe Stack)",
        section: "الالتحول الكبير",
        content: `
# حزمة الإحساس (The Vibe Stack)

يحتاج كل "مبرمج إحساس" إلى مجموعة موثوقة من الأدوات التي تعمل معاً بسلاسة. إليك الحزمة الحديثة التي توازن بين القوة، البساطة، والتوافق مع الذكاء الاصطناعي.

## الواجهة الأمامية: Next.js

**Next.js** هو إطار عمل React الذي يتعامل مع كل التعقيدات بدلاً عنك—التوجيه (Routing)، رندر الجانب السيرفر، مسارات API، والمزيد. إنه الخيار الافتراضي لأن:

- التوجيه المبني على الملفات بديهي جداً.
- مكونات السيرفر تقلل حجم الكود المرسل للمتصفح.
- تجربة تطوير رائعة مع التحديث الفوري (Hot Reload).
- يُنشر على Vercel بضغطة واحدة.

## التنسيق: Tailwind CSS

**Tailwind CSS** هو نظام تنسيق يعتمد على الكلاسات الجاهزة ويجعلك تشعر وكأنك "تغش" من شدة سهولته. بدلاً من كتابة ملفات CSS، تقوم بتنسيق المكونات مباشرة في الكود:

\`\`\`html
<button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
  اضغط هنا
</button>
\`\`\`

لماذا يناسب "الفايب":
- لا حاجة للتنقل بين ملفات CSS وHTML.
- نظام تصميم متسق مبني داخلياً.
- الذكاء الاصطناعي يفهمه بشكل مثالي.
- التصميم المتجاوب (Responsive) سهل جداً.

## الواجهة الخلفية: Supabase

**Supabase** هو البديل المفتوح لـ Firebase مع قوة PostgreSQL. يوفر لك:

- واجهات برمجة تطبيقات (APIs) فورية.
- اشتراكات في الوقت الفعلي (Real-time).
- نظام مصادقة جاهز.
- تخزين ملفات.

يمكنك الانتقال من الصفر إلى تطبيق كامل في دقائق.

## طبقة الذكاء الاصطناعي

أدوات الذكاء الاصطناعي هي مضاعف القوة لديك:

- **Cursor** — محرر كود مبني للذكاء الاصطناعي.
- **Claude / GPT-4** — زميلك المبرمج.
- **v0** — لتوليد واجهات المستخدم.
- **GitHub Copilot** — للاقتراحات السريعة.

## لماذا هذه الحزمة؟

1. **احتكاك منخفض** — كل أداة مصممة للسرعة.
2. **صديقة للذكاء الاصطناعي** — هذه الأدوات ممثلة بقوة في بيانات تدريب النماذج.
3. **جاهزة للإنتاج** — ليست مجرد ألعاب، الشركات الكبرى تستخدمها.
4. **مجتمع ضخم** — تجد إجابات لكل تساؤلاتك بسهولة.
        `,
        codeBlocks: [
          {
            language: "bash",
            title: "بداية سريعة",
            code: `# إنشاء تطبيق Next.js جديد مع Tailwind
npx create-next-app@latest my-vibe-project --typescript --tailwind

# انتقل إلى المشروع
cd my-vibe-project

# ابدأ التطوير
npm run dev`,
          },
        ],
      },
    ],
  },
  {
    name: "الأجهزة والبيئة (Hardware & Environment)",
    articles: [
      {
        slug: "prep-your-machine",
        title: "جهز جهازك (ماك/بي سي)",
        section: "الأجهزة والبيئة",
        content: `
# جهز جهازك (ماك/بي سي)

قبل أن تبدأ بالبرمجة، تحتاج إلى تهيئة جهازك. يغطي هذا الدليل الأساسيات لكل من نظام macOS وWindows.

## إعداد نظام macOS

يُفضل نظام macOS لدى معظم المطورين بسبب الطرفية (Terminal) القوية المبنية على Unix والنظام البيئي المتكامل. إليك كيفية إعداده:

### تثبيت Homebrew

**Homebrew** هو مدير الحزم المفقود لنظام macOS. يتيح لك تثبيت كل شيء من Git إلى Node.js بأوامر بسيطة.

\`\`\`bash
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
\`\`\`

بعد التثبيت، اتبع التعليمات في الشاشة لإضافة Homebrew إلى مسار النظام (PATH).

### الحزم الأساسية

\`\`\`bash
# تثبيت Git
brew install git

# تثبيت Node.js عبر nvm (موصى به)
brew install nvm

# تثبيت أدوات مفيدة
brew install gh  # واجهة GitHub البرمجية
brew install jq  # معالج ملفات JSON
\`\`\`

## إعداد نظام Windows

أصبح نظام Windows بيئة تطوير من الدرجة الأولى بفضل **WSL2** (نظام Windows الفرعي للينكس).

### تثبيت WSL2

افتح PowerShell كمسؤول (Administrator) وقم بتشغيل:

\`\`\`powershell
wsl --install
\`\`\`

سيقوم هذا بتثبيت توزيعة Ubuntu افتراضياً. قم بإعادة تشغيل الجهاز عند المطالبة بذلك.

### تهيئة WSL2

بعد إعادة التشغيل، افتح Ubuntu من قائمة "ابدأ" وقم بإنشاء حساب المستخدم الخاص بك. ثم حدث الحزم:

\`\`\`bash
sudo apt update && sudo apt upgrade -y
\`\`\`

### تثبيت الحزم الأساسية

\`\`\`bash
# تثبيت أدوات البناء
sudo apt install build-essential

# تثبيت nvm لـ Node.js
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash

# أعد تشغيل الطرفية، ثم ثبت Node
nvm install --lts
\`\`\`

## العتاد الموصى به

لأفضل تجربة برمجة بالإحساس:

- **الرام (RAM)**: الحد الأدنى 16 جيجابايت، والمثالي 32 جيجابايت.
- **التخزين**: قرص SSD إلزامي.
- **الشاشة**: شاشة كبيرة أو شاشات متعددة.
- **لوحة المفاتيح**: شيء مريح—ستكتب كثيراً.

## التحقق من البيئة

اختبر إعداداتك:

\`\`\`bash
# تحقق من Git
git --version

# تحقق من Node
node --version

# تحقق من npm
npm --version
\`\`\`

إذا أعطت كل الأوامر أرقام الإصدارات، فأنت جاهز للبدء.
        `,
      },
      {
        slug: "the-terminal",
        title: "الطرفية (The Terminal)",
        section: "الأجهزة والبيئة",
        content: `
# الطرفية (The Terminal)

الطرفية هي مركز القيادة الخاص بك. بينما تعمل الطرفيات الافتراضية بشكل جيد، تقدم البدائل الحديثة تحسينات كبيرة في جودة الحياة.

## لماذا تقوم بترقية الطرفية؟

الطرفيات الافتراضية مثل Terminal.app (ماك) أو Command Prompt (ويندوز) وظيفية ولكنها قديمة. تقدم الطرفيات الحديثة:

- **تقسيم الشاشات (Split panes)** — تشغيل عدة جلسات جنباً إلى جنب.
- **تكامل الذكاء الاصطناعي** — بعض الطرفيات تحتوي على ذكاء اصطناعي مدمج.
- **إكمال تلقائي أفضل** — اقتراحات ذكية أثناء الكتابة.
- **الثيمات** — لأن الجماليات مهمة.
- **تاريخ الأوامر** — البحث في الأوامر السابقة وإعادة استخدامها بسهولة.

## Warp (لنظام الماك)

**Warp** هو إعادة ابتكار للطرفية للقرن الحادي والعشرين. مبني بلغة Rust، سريع جداً، ويحتوي على ذكاء اصطناعي مدمج.

### المميزات:
- مخرجات مبنية على الكتل (Blocks).
- بحث عن الأوامر بالذكاء الاصطناعي.
- تحرير نصوص حديث (يعمل فيه Cmd+A و Cmd+C كما في المحررات).
- Warp Drive لمشاركة الأوامر.

### التثبيت:

\`\`\`bash
brew install --cask warp
\`\`\`

أو حمله من [warp.dev](https://warp.dev)

## Hyper (لكل الأنظمة)

**Hyper** هي طرفية مبنية على تقنيات الويب، قابلة للتخصيص بشكل لا نهائي من خلال الإضافات (Plugins).

### المميزات:
- نظام إضافات ضخم.
- ثيمات متنوعة.
- تناسق عبر جميع أنظمة التشغيل.

### التثبيت:

**ماك:**
\`\`\`bash
brew install --cask hyper
\`\`\`

**ويندوز:**
حمله من [hyper.is](https://hyper.is)

## أساسيات الطرفية

أياً كانت الطرفية التي تختارها، تعلم هذه المفاهيم:

### التنقل
- \`cd\` — تغيير المجلد.
- \`ls\` — عرض الملفات.
- \`pwd\` — عرض المسار الحالي.

### العمليات على الملفات
- \`mkdir\` — إنشاء مجلد.
- \`touch\` — إنشاء ملف.
- \`rm\` — حذف ملف (احذر!).
- \`mv\` — نقل أو إعادة تسمية.

### الإنتاجية
- \`Tab\` — إكمال تلقائي.
- \`Ctrl+R\` — البحث في التاريخ.
- \`Ctrl+C\` — إلغاء الأمر الحالي.
- \`Ctrl+L\` — مسح الشاشة.

قد تبدو الطرفية مخيفة في البداية، لكنها ستصبح طبيعية جداً مع الممارسة. ومع الذكاء الاصطناعي، يمكنك دائماً أن تسأل "كيف أفعل كذا في الطرفية؟"
        `,
      },
      {
        slug: "nodejs-setup",
        title: "إعداد Node.js",
        section: "الأجهزة والبيئة",
        content: `
# إعداد Node.js

**Node.js** هو محرك التشغيل الذي يتيح لك تشغيل جافا سكريبت خارج المتصفح. إنه ضروري لتطوير الويب الحديث.

## ما هو Node.js؟

فكر في Node.js كالمحرك الذي يشغل:
- سيرفرات التطوير الخاصة بك.
- بناء مشاريعك.
- إدارة المكتبات عبر npm.
- تشغيل السكربتات والأتمتة.

## لماذا نستخدم nvm؟

**nvm** (مدير إصدارات Node) هو الطريقة الموصى بها لتثبيت Node.js لأن:

1. **لا توجد مشاكل صلاحيات** — يثبت في مجلد المستخدم الخاص بك.
2. **إصدارات متعددة** — التبديل بين إصدارات Node بسهولة.
3. **تحديثات سهلة** — حدث Node بأمر واحد.
4. **مرونة المشاريع** — يمكن للمشاريع المختلفة استخدام إصدارات مختلفة.

## التثبيت

### ماك (باستخدام Homebrew)

\`\`\`bash
# تثبيت nvm
brew install nvm

# أضفه إلى إعدادات الشيل الخاصة بك (~/.zshrc)
export NVM_DIR="$HOME/.nvm"
[ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && \\. "/opt/homebrew/opt/nvm/nvm.sh"

# أعد تحميل الإعدادات
source ~/.zshrc
\`\`\`

### ويندوز (WSL) / لينكس

\`\`\`bash
# تثبيت nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash

# أعد تحميل الإعدادات
source ~/.bashrc
\`\`\`

## استخدام nvm

\`\`\`bash
# تثبيت أحدث إصدار مستقر (LTS)
nvm install --lts

# استخدام الإصدار المثبت
nvm use --lts

# تعيينه كإصدار افتراضي
nvm alias default node

# التحقق من التثبيت
node --version
npm --version
\`\`\`

## أساسيات npm

**npm** (مدير حزم Node) يأتي مع Node.js:

\`\`\`bash
# تهيئة مشروع جديد
npm init -y

# تثبيت مكتبة
npm install react

# تثبيت كمكتبة تطوير
npm install -D typescript

# تشغيل سكربت
npm run dev
\`\`\`

مع إعداد nvm بشكل صحيح، لن تواجه مشاكل في صلاحيات Node.js مرة أخرى.
        `,
      },
    ],
  },
  {
    name: "التحكم في الإصدارات (Version Control)",
    articles: [
      {
        slug: "what-is-git",
        title: "ما هو Git؟",
        section: "التحكم في الإصدارات",
        content: `
# ما هو Git؟

**Git** هو نظام للتحكم في الإصدارات—فكر فيه كنظام حفظ (Save) متطور لكودك يتتبع كل تغيير قمت به على الإطلاق.

## تشبيه ألعاب الفيديو

تخيل أنك تلعب لعبة تقمص أدوار (RPG):

- **نقطة حفظ (Save Point)** = Git Commit
- **ملف الحفظ (Save File)** = مستودع Git (Repository)
- **خانات حفظ مختلفة** = فروع Git (Branches)
- **تحميل حفظ سابق** = Git Checkout
- **الحفظ السحابي** = GitHub

عندما تقوم بعمل "Commit"، فأنت تنشئ نقطة حفظ. يمكنك دائماً العودة إلى أي حفظ سابق.

## المفاهيم الأساسية

### المستودع (Repo)
هو مجلد مشروعك مع تفعيل تتبع Git فيه.

### الـ Commit
هو لقطة (Snapshot) لكودك في لحظة معينة.

### الفرع (Branch)
هو خط زمني موازي لكودك. استخدم الفروع لـ:
- العمل على ميزات جديدة دون تخريب الكود الرئيسي.
- التجربة بأمان.
- التعاون مع الآخرين.

### التدفق الأساسي

\`\`\`bash
# 1. قم بإجراء تغييرات على ملفاتك

# 2. أضف التغييرات لمرحلة التجهيز
git add .

# 3. احفظ التغييرات برسالة وصفية
git commit -m "إضافة نظام تسجيل الدخول"

# 4. ارفعها إلى السحاب (GitHub)
git push
\`\`\`

لا تخف من Git، إنه موجود لحمايتك وليس لمعاقبتك.
        `,
      },
      {
        slug: "github-basics",
        title: "أساسيات GitHub",
        section: "التحكم في الإصدارات",
        content: `
# أساسيات GitHub

**GitHub** هو المكان الذي يعيش فيه كودك على الإنترنت. إنه Git + ميزات اجتماعية + أدوات تعاون.

## لماذا GitHub؟

- **نسخة احتياطية** — كودك آمن في السحاب.
- **التعاون** — العمل مع الآخرين بسهولة.
- **معرض أعمال (Portfolio)** — اعرض عملك لأصحاب العمل.
- **المجتمع** — الوصول لملايين المشاريع المفتوحة المصدر.

## الإعداد

### إنشاء حساب
اذهب إلى [github.com](https://github.com) وقم بالتسجيل. اختر اسماً مهنياً—هذه هويتك كمطور.

### تهيئة Git

\`\`\`bash
# تعيين هويتك
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
\`\`\`

## رفع أول مشروع

\`\`\`bash
# تهيئة مشروعك
git init

# إضافة كل الملفات
git add .

# أول حفظ
git commit -m "البداية"

# ربطه بمستودع على GitHub
git remote add origin https://github.com/username/repo-name.git

# الرفع
git push -u origin main
\`\`\`

GitHub هو قاعدتك الأساسية، تعود عليه جيداً.
        `,
      },
    ],
  },
  {
    name: "حقيبة أدوات الذكاء الاصطناعي (The AI Toolbelt)",
    articles: [
      {
        slug: "the-editor",
        title: "المحرر (The Editor)",
        section: "حقيبة أدوات الذكاء الاصطناعي",
        content: `
# المحرر: Cursor

**Cursor** هو محرر كود مبني خصيصاً للذكاء الاصطناعي. إنه السلاح المفضل لـ "مبرمج الإحساس".

## لماذا Cursor وليس VS Code؟

Cursor مبني على VS Code، لكنه يأخذ الذكاء الاصطناعي لمستوى آخر:

- **إكمال الأكواد المتقدم**: يتوقع ما ستكتبه بدقة مذهلة.
- **المحادثة مع الكود**: يمكنك الدردشة مع مشروعك بالكامل.
- **التعديل في عدة ملفات**: يمكنه إجراء تغييرات عبر مشروعك بضغطة واحدة.
- **فهم عميق للكود**: يعرف كيف ترتبط ملفاتك ببعضها.

## ميزات مفتاحية

### Cmd+K (تعديل مباشر)
ظلل الكود، واضغط Cmd+K، واوصف ما تريد تعديله:
- "أضف معالجة أخطاء لهذه الدالة"
- "حول هذا المكون إلى TypeScript"

### Cmd+L (الدردشة)
افتح لوحة الدردشة واسأل عن أي شيء في مشروعك.

### Composer (Cmd+I)
هذه هي القوة الحقيقية. يمكنه:
- بناء ميزات كاملة من الصفر.
- إنشاء ملفات جديدة وتعديل القديمة في وقت واحد.

Cursor يحولك إلى مطور خارق من خلال التعامل مع الأجزاء الميكانيكية للبرمجة بينما تركز أنت على الإبداع.
        `,
      },
      {
        slug: "llms-explained",
        title: "شرح نماذج اللغة (LLMs Explained)",
        section: "حقيبة أدوات الذكاء الاصطناعي",
        content: `
# شرح نماذج اللغة (LLMs)

نماذج اللغة الكبيرة هي الذكاء الاصطناعي الذي يشغل مساعدي البرمجة لديك. فهم نقاط قوتها يساعدك في اختيار الأداة المناسبة.

## اللاعبون الكبار

### Claude (من شركة Anthropic)
**Claude 3.5 Sonnet** هو حالياً الخيار الأول للبرمجة:
- ممتاز في اتباع التعليمات المعقدة.
- تفكير منطقي قوي جداً.
- رائع في شرح أسباب اختيار حلول معينة.

### GPT-4 (من شركة OpenAI)
**GPT-4o** هو النموذج الرائد من OpenAI:
- سريع جداً في الاستجابة.
- ذكاء عام قوي.
- رائع في المهام السريعة والمتكررة.

## كيف تختار النموذج المناسب؟

| المهمة | الخيار الأفضل | لماذا؟ |
|--------|---------------|---------|
| حل مشكلة معقدة | Claude | تفكير أعمق |
| استكمال كود سريع | GPT-4o | أسرع |
| بناء معمارية مشروع | Claude | دقة أعلى |

دائماً اختبر النماذج المختلفة، فالمجال يتطور بسرعة مذهلة.
        `,
      },
      {
        slug: "prompt-engineering",
        title: "أساسيات هندسة البرومبت",
        section: "حقيبة أدوات الذكاء الاصطناعي",
        content: `
# أساسيات هندسة البرومبت

هندسة البرومبت (Prompt Engineering) هي مهارة التواصل الفعال مع الذكاء الاصطناعي. إنها أهم مهارة لـ "مبرمج الإحساس".

## معادلة البرومبت الناجح

\`\`\`
[السياق] + [المهمة المحددة] + [القيود] + [التنسيق المطلوب]
\`\`\`

### مثال:
**برومبت سيء:** "اصنع لي صفحة تسجيل دخول"

**برومبت جيد:** "أنا أبني تطبيقاً باستخدام Next.js و Tailwind. [سياق] أنشئ مكوناً لصفحة تسجيل الدخول يحتوي على البريد الإلكتروني وكلمة المرور. [مهمة] استخدم التحقق من المدخلات ولا تستخدم مكتبات خارجية. [قيود] صممه كـ Client Component باستخدام TypeScript. [تنسيق]"

كلما كنت أكثر دقة ووضوحاً، حصلت على نتائج أفضل بكثير.
        `,
      },
    ],
  },
  {
    name: "البناء والشحن (Building & Shipping)",
    articles: [
      {
        slug: "hello-world-with-ai",
        title: "أول مشروع مع الذكاء الاصطناعي",
        section: "البناء والشحن",
        content: `
# أول مشروع مع الذكاء الاصطناعي

لنقم ببناء أول مكون لك باستخدام الذكاء الاصطناعي. سنقوم بإنشاء قسم "Hero" لصفحة هبوط.

## البرومبت المقترح

افتح Composer في Cursor واكتب:

\`\`\`
أنشئ قسم Hero لصفحة هبوط لمنتج تقني.
المتطلبات:
- عنوان جذاب مع نص متدرج الألوان (Gradient).
- وصف يشرح المنتج.
- زرين لاتخاذ إجراء (Call to Action).
- استخدم Tailwind CSS.
- اجعل التصميم متجاوباً مع الجوال.
- أضف حركات خفيفة عند التحميل.
\`\`\`

ستندهش من جودة الكود الذي سيولده الذكاء الاصطناعي لك في ثوانٍ. تذكر أن تراجع الكود وتعدل عليه ليصل للنتيجة التي تحلم بها.
        `,
      },
      {
        slug: "iterating",
        title: "التكرار والتصحيح",
        section: "البناء والشحن",
        content: `
# التكرار والتصحيح

الأشياء سوف تتعطل، وهذا جزء من العملية. إليك كيف تصحح الأخطاء مع الذكاء الاصطناعي.

## حلقة تصحيح الأخطاء

1. **انسخ رسالة الخطأ بالكامل**.
2. **ألصقها للذكاء الاصطناعي**.
3. **أرفق الكود المتعلق بالخطأ**.
4. **طبق الإصلاح المقترح**.
5. **كرر العملية إذا لزم الأمر**.

الذكاء الاصطناعي رائع في قراءة سجلات الأخطاء (Logs) وفهم سبب المشكلة بسرعة. لا تحاول حل كل شيء بنفسك، استشر زميلك الآلي!
        `,
      },
      {
        slug: "deployment",
        title: "نشر المشروع (Deployment)",
        section: "البناء والشحن",
        content: `
# نشر المشروع: اشحن للعالم

لقد بنيت شيئاً رائعاً، الآن حان الوقت ليراه العالم. منصة **Vercel** تجعل هذا الأمر سهلاً بشكل مذهل.

## لماذا Vercel؟

- **تكامل مثالي مع Next.js**.
- **خطة مجانية سخية جداً**.
- **نشر تلقائي**: بمجرد أن ترفع كودك لـ GitHub، يتم تحديث موقعك تلقائياً.
- **سرعة هائلة** في تحميل المواقع.

## كيف تنشر؟

1. ارفع كودك إلى GitHub.
2. اربط حساب GitHub بـ Vercel.
3. اختر المستودع واضغط "Deploy".

مبروك! موقعك الآن متاح للجميع على الإنترنت.
        `,
      },
    ],
  },
  {
    name: "أدوات الذكاء الاصطناعي المتقدمة (Advanced AI Tools)",
    articles: [
      {
        slug: "cursor-vs-windsurf",
        title: "Cursor مقابل Windsurf: مقارنة شاملة",
        section: "أدوات الذكاء الاصطناعي المتقدمة",
        content: `
# Cursor مقابل Windsurf: أي محرر ذكاء اصطناعي تختار؟

في عالم البرمجة بمساعدة الذكاء الاصطناعي، ظهر محرران رائدان يتنافسان على لقب أفضل بيئة تطوير: **Cursor** و **Windsurf** (من شركة Codeium). كلاهما يعد بتحويل طريقة برمجتك، لكن أيهما يناسبك أكثر؟ في هذا الدليل الشامل، سنقارن بينهما من جميع الجوانب لمساعدتك في اتخاذ القرار الصحيح.

## نظرة عامة على كل محرر

### Cursor: الرائد في سوق محررات الذكاء الاصطناعي

**Cursor** هو محرر كود مبني على VS Code، تم تصميمه من الألف إلى الياء مع الذكاء الاصطناعي في جوهره. أُطلق في 2023 وسرعان ما أصبح المفضل لدى المطورين الذين يريدون تجربة برمجة مدعومة بالذكاء الاصطناعي بشكل عميق.

**المميزات الرئيسية:**
- **Composer (Cmd+I)**: أداة لبناء ميزات كاملة عبر ملفات متعددة
- **Chat (Cmd+L)**: محادثة سياقية مع الكود
- **Inline Edit (Cmd+K)**: تعديل مباشر في السطور المحددة
- **تكامل عميق مع Claude و GPT-4**
- **فهم كامل لسياق المشروع**

### Windsurf: المنافس الجديد من Codeium

**Windsurf** هو محرر أطلقته شركة Codeium المعروفة بإضافة الإكمال التلقائي المجانية. يهدف لتقديم تجربة "Agentic IDE" حيث يعمل الذكاء الاصطناعي كوكيل مستقل يمكنه تنفيذ مهام معقدة.

**المميزات الرئيسية:**
- **Cascade**: وكيل ذكاء اصطناعي يمكنه تصفح الملفات وتنفيذ الأوامر
- **Supercomplete**: إكمال تلقائي متقدم
- **تشغيل أوامر الطرفية تلقائياً**
- **خطة مجانية سخية**
- **دعم عدة نماذج ذكاء اصطناعي**

## مقارنة الميزات الأساسية

### 1. إكمال الكود التلقائي (Autocomplete)

| المعيار | Cursor | Windsurf |
|---------|--------|----------|
| السرعة | سريع جداً | سريع جداً |
| الدقة | ممتازة مع Claude | ممتازة مع Cascade |
| فهم السياق | عميق | عميق |
| اقتراحات متعددة الأسطر | نعم | نعم |

**الفائز**: تعادل - كلاهما يقدم إكمالاً تلقائياً من المستوى الأول.

### 2. المحادثة مع الكود (Chat)

**Cursor** يتميز بـ:
- القدرة على اختيار النموذج (Claude 3.5, GPT-4, GPT-4o)
- إضافة ملفات محددة للسياق بسهولة
- تطبيق التغييرات المقترحة بضغطة واحدة

**Windsurf** يتميز بـ:
- تكامل أعمق مع الطرفية
- تنفيذ الأوامر تلقائياً
- تصفح الملفات والبحث عن المعلومات

**الفائز**: يعتمد على أسلوب عملك. Cursor أفضل للتحكم اليدوي، Windsurf أفضل للأتمتة.

### 3. التعديل عبر ملفات متعددة (Multi-file Editing)

هنا يتفوق **Cursor** بشكل واضح:
- **Composer** يمكنه إنشاء وتعديل عشرات الملفات في جلسة واحدة
- عرض Diff واضح لكل تغيير
- إمكانية قبول أو رفض كل تغيير على حدة

**Windsurf** يقدم:
- قدرات مشابهة عبر Cascade
- لكن العرض أقل وضوحاً
- التحكم في التغييرات أصعب قليلاً

**الفائز**: Cursor

### 4. فهم قاعدة الكود (Codebase Understanding)

| القدرة | Cursor | Windsurf |
|--------|--------|----------|
| الفهرسة | ممتازة | ممتازة |
| البحث الدلالي | نعم | نعم |
| الملفات الكبيرة | يتعامل معها جيداً | يتعامل معها جيداً |
| المشاريع الضخمة | قد يبطئ | أداء أفضل |

**الفائز**: تعادل

## التسعير والخطط

### Cursor

- **مجاني (Hobby)**: 2000 إكمال + 50 طلب بطيء شهرياً
- **Pro ($20/شهر)**: إكمال غير محدود + 500 طلب سريع
- **Business ($40/شهر)**: ميزات للفرق + أمان متقدم

### Windsurf

- **مجاني**: إكمال غير محدود + رصيد Cascade محدود
- **Pro ($15/شهر)**: كل شيء غير محدود
- **Teams ($25/شهر)**: ميزات للفرق

**الفائز**: Windsurf - أرخص وخطته المجانية أسخى.

## دليل الإعداد السريع

### إعداد Cursor

\`\`\`bash
# 1. حمل Cursor من cursor.com
# 2. ثبته وافتحه

# 3. اربطه بحساب Cursor
# Settings > Sign In

# 4. اختر النموذج المفضل
# Settings > Models > Claude 3.5 Sonnet (موصى به)

# 5. فعّل الميزات المهمة
# Settings > Features > Enable Composer
# Settings > Features > Enable Codebase Indexing
\`\`\`

**اختصارات أساسية:**
- \`Cmd+K\` / \`Ctrl+K\`: تعديل مباشر
- \`Cmd+L\` / \`Ctrl+L\`: فتح الدردشة
- \`Cmd+I\` / \`Ctrl+I\`: فتح Composer
- \`Cmd+Shift+K\`: إكمال في السطر

### إعداد Windsurf

\`\`\`bash
# 1. حمل Windsurf من codeium.com/windsurf
# 2. ثبته وافتحه

# 3. سجل الدخول أو أنشئ حساباً
# يمكنك تسجيل الدخول بـ Google أو GitHub

# 4. فعّل Cascade
# الشريط الجانبي > Cascade

# 5. اضبط الإعدادات
# Settings > AI > Preferred Model
\`\`\`

**اختصارات أساسية:**
- \`Cmd+I\` / \`Ctrl+I\`: فتح Cascade
- \`Cmd+L\` / \`Ctrl+L\`: دردشة سريعة
- \`Tab\`: قبول الإكمال التلقائي
- \`Cmd+Enter\`: تنفيذ الإجراء

## متى تختار Cursor؟

اختر **Cursor** إذا:

1. **تريد تحكماً دقيقاً** في ما يفعله الذكاء الاصطناعي
2. **تعمل على مشاريع معقدة** تتطلب فهماً عميقاً للسياق
3. **تفضل Claude** كنموذج أساسي
4. **تحتاج لتعديلات عبر ملفات كثيرة** بشكل متكرر
5. **أنت معتاد على VS Code** وتريد تجربة مألوفة

## متى تختار Windsurf؟

اختر **Windsurf** إذا:

1. **تريد تجربة أكثر أتمتة** حيث الذكاء الاصطناعي يفعل أكثر بنفسه
2. **الميزانية محدودة** وتحتاج خطة مجانية سخية
3. **تحب أن ينفذ الذكاء الاصطناعي الأوامر** في الطرفية
4. **تبني نماذج أولية سريعة** وتريد أتمتة عالية
5. **تعمل على مشاريع ضخمة** حيث الأداء مهم

## نصائح للاستفادة القصوى من كل محرر

### نصائح لـ Cursor

1. **استخدم @ للإشارة للملفات**: في الدردشة، اكتب \`@filename.ts\` لإضافته للسياق
2. **فعّل الفهرسة**: تأكد من فهرسة مشروعك للحصول على نتائج أفضل
3. **استخدم .cursorrules**: أنشئ ملف قواعد خاص بمشروعك
4. **جرب نماذج مختلفة**: كل نموذج له نقاط قوة مختلفة

\`\`\`plaintext
# مثال لملف .cursorrules
أنا أعمل على مشروع Next.js 14 مع TypeScript.
استخدم App Router دائماً.
اتبع أفضل الممارسات للأداء.
اكتب كوداً نظيفاً وقابلاً للصيانة.
\`\`\`

### نصائح لـ Windsurf

1. **اترك Cascade يستكشف**: أعطه حرية تصفح الملفات
2. **راقب تنفيذ الأوامر**: تأكد من فهم ما يفعله
3. **استخدم Supercomplete**: لا تقبل كل اقتراح، انتظر الأفضل
4. **وفر رصيدك**: الخطة المجانية لها حدود

## الخلاصة: أيهما الأفضل؟

**لا يوجد فائز مطلق** - كلاهما أداتان ممتازتان تخدمان أغراضاً مختلفة قليلاً:

| المعيار | الفائز |
|---------|--------|
| التحكم والدقة | Cursor |
| الأتمتة | Windsurf |
| السعر | Windsurf |
| التعديل المتعدد | Cursor |
| الأداء | Windsurf |
| النظام البيئي | Cursor |

**توصيتي الشخصية:**

- **للمبتدئين**: ابدأ بـ **Windsurf** لأنه مجاني ويساعدك أكثر
- **للمحترفين**: **Cursor** يعطيك تحكماً أدق وإنتاجية أعلى
- **للميزانية المحدودة**: **Windsurf** بلا منازع
- **لبناء المنتجات**: **Cursor Pro** يستحق الاستثمار

الخبر السار؟ يمكنك تثبيت كليهما وتجربتهما! الأدوات مجانية للتجربة، والخبرة العملية خير من ألف مقال.

## الموارد الإضافية

- [موقع Cursor الرسمي](https://cursor.com)
- [موقع Windsurf الرسمي](https://codeium.com/windsurf)
- [توثيق Cursor](https://cursor.com/docs)
- [مجتمع Codeium](https://discord.gg/codeium)

جرب كلا المحررين لمدة أسبوع، ثم اختر ما يناسب أسلوب عملك. البرمجة بالإحساس تعني إيجاد الأدوات التي تتناغم مع طريقة تفكيرك!
        `,
        codeBlocks: [
          {
            language: "bash",
            title: "تثبيت المحررين",
            code: `# تثبيت Cursor على macOS
brew install --cask cursor

# تثبيت Windsurf على macOS
brew install --cask windsurf

# أو حملهما من المواقع الرسمية:
# cursor.com
# codeium.com/windsurf`,
          },
        ],
      },
    ],
  },
  {
    name: "أنماط البرمجة (Coding Patterns)",
    articles: [
      {
        slug: "conversational-coding",
        title: "البرمجة التحادثية: فن الحوار مع الذكاء الاصطناعي",
        section: "أنماط البرمجة",
        content: `
# البرمجة التحادثية: فن الحوار مع الذكاء الاصطناعي

البرمجة التحادثية (Conversational Coding) هي أسلوب جديد في تطوير البرمجيات حيث تتحول البرمجة من كتابة الكود يدوياً إلى محادثة مستمرة مع زميل ذكي لا يتعب. في هذا المقال، ستتعلم كيف تتواصل بفعالية مع الذكاء الاصطناعي لتحقيق أقصى إنتاجية.

## ما هي البرمجة التحادثية؟

البرمجة التحادثية تعني التعامل مع الذكاء الاصطناعي كزميل برمجة حقيقي. بدلاً من كتابة كل سطر بنفسك، أنت:

1. **تشرح ما تريد بناءه** بلغة طبيعية
2. **تراجع ما يقترحه** الذكاء الاصطناعي
3. **تطلب تعديلات** على المقترحات
4. **تكرر العملية** حتى تصل للنتيجة المطلوبة

هذا يختلف جذرياً عن استخدام الذكاء الاصطناعي كأداة بحث أو مولد كود بسيط.

## المبادئ الأساسية للتواصل الفعال

### 1. ابدأ بالسياق

الذكاء الاصطناعي لا يعرف مشروعك كما تعرفه أنت. ابدأ دائماً بتوفير السياق:

**❌ طريقة سيئة:**
\`\`\`
اصنع لي form
\`\`\`

**✅ طريقة جيدة:**
\`\`\`
أنا أبني تطبيق Next.js 14 للتجارة الإلكترونية باستخدام TypeScript و Tailwind.
أحتاج نموذج (form) لتسجيل حساب جديد يحتوي على:
- الاسم الكامل
- البريد الإلكتروني
- كلمة المرور (مع تأكيد)
- رقم الهاتف (اختياري)
استخدم React Hook Form للتحقق من المدخلات.
\`\`\`

### 2. كن محدداً ولكن ليس مفرطاً

هناك توازن بين الغموض والتفصيل المفرط:

| مستوى التفصيل | المشكلة |
|--------------|---------|
| غامض جداً | نتائج عشوائية |
| مثالي | نتائج دقيقة |
| مفصل جداً | يقيد إبداع الذكاء الاصطناعي |

**مثال على التوازن المثالي:**
\`\`\`
أنشئ مكون Button قابل لإعادة الاستخدام:
- ثلاثة أحجام: sm, md, lg
- ثلاثة أنواع: primary, secondary, outline
- دعم حالة التحميل مع spinner
- تأثيرات hover و focus
- TypeScript مع props موثقة
\`\`\`

### 3. استخدم أسلوب المحادثة المتدرج

لا تحاول شرح كل شيء في رسالة واحدة. المحادثة المتدرجة أفضل:

**الجولة 1: الإطار العام**
\`\`\`
أريد بناء dashboard لإدارة المهام.
الصفحة الرئيسية تعرض:
- إحصائيات المهام
- قائمة المهام الحالية
- زر إضافة مهمة جديدة
\`\`\`

**الجولة 2: التفاصيل**
\`\`\`
رائع! الآن دعنا نحسن قسم الإحصائيات:
- أضف رسم بياني للمهام المنجزة هذا الأسبوع
- استخدم recharts للرسوم البيانية
- أضف animation عند التحميل
\`\`\`

**الجولة 3: التحسينات**
\`\`\`
أحببت النتيجة! تعديلات صغيرة:
- غير لون الرسم البياني للتدرج الأزرق
- أضف tooltip عند hover على النقاط
- اجعل التحديث كل 30 ثانية
\`\`\`

## تقنيات البرومبت المتقدمة

### 1. تقنية "Act As" (تقمص الدور)

اطلب من الذكاء الاصطناعي تقمص دور معين:

\`\`\`
تصرف كمهندس أمان متخصص في تطبيقات الويب.
راجع كود المصادقة التالي وحدد الثغرات الأمنية المحتملة:

[الكود هنا]
\`\`\`

### 2. تقنية "Few-Shot" (التعلم بالأمثلة)

قدم أمثلة على ما تريده:

\`\`\`
أريد توحيد أسلوب أسماء الدوال في المشروع.

الأسلوب المطلوب:
- getUserById ✓
- get_user_by_id ✗
- GetUserById ✗

حول هذه الدوال للأسلوب الصحيح:
- fetch_all_products
- CreateNewOrder
- delete_item_from_cart
\`\`\`

### 3. تقنية "Chain of Thought" (سلسلة التفكير)

اطلب من الذكاء الاصطناعي شرح تفكيره:

\`\`\`
أحتاج خوارزمية لترتيب المنتجات في صفحة المتجر.
المعايير:
- الأكثر مبيعاً
- الأحدث
- التقييم
- السعر

اشرح تفكيرك خطوة بخطوة قبل كتابة الكود.
كيف ستوازن بين هذه المعايير؟
\`\`\`

### 4. تقنية "Rubber Duck" (البطة المطاطية)

استخدم الذكاء الاصطناعي لتوضيح أفكارك:

\`\`\`
أحاول فهم مشكلة في الكود.
عندما يضغط المستخدم على زر "حفظ":
1. يتم إرسال البيانات للـ API
2. يظهر loading spinner
3. لكن أحياناً تُحفظ البيانات مرتين!

ساعدني في التفكير: ما الذي يمكن أن يسبب هذا؟
\`\`\`

## أنماط المحادثة الشائعة

### نمط "Build → Review → Refine"

\`\`\`
[أنت] ابنِ مكون للتعليقات

[الذكاء الاصطناعي] [يقدم الكود]

[أنت] جيد، لكن:
- أضف pagination
- استخدم infinite scroll بدلاً من الأزرار
- أضف تحميل skeleton

[الذكاء الاصطناعي] [يعدل الكود]

[أنت] ممتاز، أضف اختبارات Jest لهذا المكون

[الذكاء الاصطناعي] [يضيف الاختبارات]
\`\`\`

### نمط "Explain → Implement"

\`\`\`
[أنت] اشرح لي كيف يعمل WebSocket في المتصفح

[الذكاء الاصطناعي] [يشرح المفهوم]

[أنت] الآن طبق هذا في مشروعي.
أريد real-time notifications.

[الذكاء الاصطناعي] [يكتب الكود]
\`\`\`

### نمط "Debug Together"

\`\`\`
[أنت] هذا الخطأ يظهر عندما أحاول حفظ المستخدم:
TypeError: Cannot read property 'id' of undefined

الكود المتعلق:
[الكود]

[الذكاء الاصطناعي] [يحلل المشكلة]

[أنت] فهمت، لكن لماذا user أحياناً undefined؟

[الذكاء الاصطناعي] [يشرح سبب المشكلة الجذري]
\`\`\`

## أخطاء شائعة يجب تجنبها

### 1. الاعتماد الأعمى

**❌ خطأ:** نسخ الكود مباشرة دون فهمه
**✅ صحيح:** اطلب شرحاً لأي جزء لا تفهمه

\`\`\`
ما الفرق بين useMemo و useCallback في الكود الذي كتبته؟
لماذا استخدمت أحدهما هنا والآخر هناك؟
\`\`\`

### 2. عدم توفير الأخطاء الكاملة

**❌ خطأ:** "الكود لا يعمل"
**✅ صحيح:** انسخ رسالة الخطأ كاملة مع stack trace

### 3. تجاهل السياق التراكمي

**❌ خطأ:** بدء محادثة جديدة لكل سؤال
**✅ صحيح:** استمر في نفس المحادثة للحفاظ على السياق

### 4. البرومبتات الطويلة جداً

**❌ خطأ:** رسالة من 500 كلمة تطلب 10 أشياء
**✅ صحيح:** رسائل مركزة، كل رسالة تطلب شيئاً أو شيئين

## نصائح متقدمة

### استخدم الملفات المرفقة بذكاء

في Cursor و Windsurf، يمكنك إرفاق ملفات للسياق:

\`\`\`
@components/Button.tsx
@lib/utils.ts

أنشئ مكون Card يتبع نفس أسلوب Button
واستخدم دوال utils الموجودة
\`\`\`

### وثق القرارات المهمة

\`\`\`
قررنا استخدام Zustand بدلاً من Redux.
السبب: مشروع صغير ولا نحتاج تعقيد Redux.

الآن، أنشئ store لإدارة سلة المشتريات.
\`\`\`

### اطلب البدائل

\`\`\`
أعطني 3 طرق مختلفة لتنفيذ lazy loading للصور.
لكل طريقة اذكر:
- الإيجابيات
- السلبيات
- متى تستخدمها
\`\`\`

## تمارين عملية

### تمرين 1: بناء محادثة متدرجة

حاول بناء صفحة "من نحن" لموقع شركة تقنية. استخدم هذا التسلسل:
1. اطلب الهيكل العام
2. أضف قسم الفريق
3. أضف الرسوم المتحركة
4. أضف responsive design

### تمرين 2: تصحيح خطأ

خذ خطأً واجهته مؤخراً وحاول شرحه للذكاء الاصطناعي. لاحظ كيف:
- السياق يساعد
- رسالة الخطأ الكاملة ضرورية
- الأسئلة التوضيحية تسرع الحل

## الخلاصة

البرمجة التحادثية ليست مجرد استخدام ChatGPT للبرمجة. إنها **مهارة** تتحسن بالممارسة. المفاتيح الرئيسية:

1. **السياق أولاً**: اشرح بيئتك ومشروعك
2. **التدرج**: ابنِ المحادثة خطوة بخطوة
3. **الوضوح**: كن محدداً دون إفراط
4. **التفاعل**: راجع واطلب تعديلات
5. **الفهم**: لا تنسخ دون فهم

مع الوقت، ستطور أسلوبك الخاص في التواصل مع الذكاء الاصطناعي، وستجد أن إنتاجيتك تتضاعف مرات عديدة. البرمجة بالإحساس تبدأ بمحادثة جيدة!
        `,
      },
    ],
  },
  {
    name: "دراسات حالة حقيقية (Real-World Case Studies)",
    articles: [
      {
        slug: "saas-in-a-week",
        title: "بناء SaaS في أسبوع: دراسة حالة عملية",
        section: "دراسات حالة حقيقية",
        content: `
# بناء SaaS في أسبوع: دراسة حالة عملية

هل يمكن بناء منتج SaaS كامل في أسبوع واحد فقط؟ مع أدوات الذكاء الاصطناعي الحديثة، الإجابة نعم! في هذه الدراسة، سنوثق رحلة بناء **TaskFlow** - تطبيق لإدارة المهام للفرق الصغيرة - من الفكرة إلى الإطلاق في 7 أيام.

## نظرة عامة على المشروع

### ما هو TaskFlow؟

تطبيق ويب لإدارة المهام يتيح للفرق الصغيرة:
- إنشاء وتتبع المهام
- تنظيم المهام في مشاريع
- التعاون في الوقت الفعلي
- تتبع التقدم بلوحات Kanban

### الأدوات المستخدمة

| الفئة | الأداة |
|-------|-------|
| المحرر | Cursor مع Claude 3.5 |
| Frontend | Next.js 14, TypeScript, Tailwind |
| Backend | Supabase (Auth, DB, Realtime) |
| Hosting | Vercel |
| الدفع | Stripe |
| التصميم | v0.dev للمكونات الأولية |

### الميزانية الإجمالية

- Cursor Pro: $20
- Supabase: $0 (Free tier)
- Vercel: $0 (Hobby)
- نطاق (Domain): $12
- **المجموع: $32**

## اليوم الأول: التخطيط والإعداد

### الساعات 1-2: تحديد النطاق

بدأت بجلسة عصف ذهني مع Claude:

\`\`\`
أريد بناء SaaS لإدارة المهام.
الجمهور المستهدف: فرق من 3-10 أشخاص.
الميزانية: أقل من $50.
الوقت: أسبوع واحد.

ما الميزات الأساسية (MVP) التي يجب أن أبدأ بها؟
وما الميزات التي يمكن تأجيلها؟
\`\`\`

**النتيجة:**
- MVP: المصادقة، المهام، المشاريع، Kanban
- المؤجل: الإشعارات، التقارير، تكامل Slack

### الساعات 3-4: إعداد المشروع

\`\`\`bash
# إنشاء المشروع
npx create-next-app@latest taskflow --typescript --tailwind --app

# إضافة المكتبات
npm install @supabase/supabase-js @supabase/auth-helpers-nextjs
npm install @dnd-kit/core @dnd-kit/sortable
npm install zustand
\`\`\`

### الساعتان 5-6: إعداد Supabase

أنشأت مشروعاً في Supabase وطلبت من Claude:

\`\`\`
أنشئ schema لقاعدة بيانات تطبيق إدارة مهام:
- Users (يديره Supabase Auth)
- Teams
- Projects  
- Tasks (مع drag & drop ترتيب)

أضف Row Level Security لكل جدول.
\`\`\`

**نتيجة اليوم الأول:**
- مشروع Next.js جاهز
- قاعدة بيانات مصممة
- RLS مفعّل
- بيئة التطوير تعمل

## اليوم الثاني: نظام المصادقة

### نظام تسجيل الدخول

استخدمت Cursor Composer لبناء:

\`\`\`
ابنِ نظام مصادقة كامل مع Supabase:
1. صفحة تسجيل الدخول (email/password)
2. صفحة إنشاء حساب
3. صفحة استعادة كلمة المرور
4. Middleware لحماية الصفحات
5. Context للمستخدم الحالي

استخدم App Router و Server Actions.
التصميم بـ Tailwind - عصري ونظيف.
\`\`\`

### الملفات المُنشأة

\`\`\`
app/
├── (auth)/
│   ├── login/page.tsx
│   ├── signup/page.tsx
│   └── reset-password/page.tsx
├── (dashboard)/
│   └── layout.tsx  (protected)
lib/
├── supabase/
│   ├── client.ts
│   └── server.ts
middleware.ts
\`\`\`

**نتيجة اليوم الثاني:**
- تسجيل دخول يعمل
- حماية الصفحات
- تجربة مستخدم سلسة

## اليوم الثالث: نموذج البيانات والـ API

### بناء Server Actions

\`\`\`typescript
// actions/tasks.ts
'use server'

export async function createTask(data: TaskInput) {
  const supabase = createServerClient()
  const { data: task, error } = await supabase
    .from('tasks')
    .insert(data)
    .select()
    .single()
  
  if (error) throw error
  revalidatePath('/dashboard')
  return task
}

export async function updateTaskOrder(tasks: TaskOrder[]) {
  const supabase = createServerClient()
  // Batch update with transaction
  const updates = tasks.map(t => 
    supabase.from('tasks').update({ order: t.order }).eq('id', t.id)
  )
  await Promise.all(updates)
  revalidatePath('/dashboard')
}
\`\`\`

### Zustand Store

\`\`\`typescript
// stores/taskStore.ts
interface TaskStore {
  tasks: Task[]
  projects: Project[]
  setTasks: (tasks: Task[]) => void
  addTask: (task: Task) => void
  moveTask: (taskId: string, newStatus: Status) => void
}

export const useTaskStore = create<TaskStore>((set) => ({
  tasks: [],
  projects: [],
  setTasks: (tasks) => set({ tasks }),
  addTask: (task) => set((state) => ({ 
    tasks: [...state.tasks, task] 
  })),
  moveTask: (taskId, newStatus) => set((state) => ({
    tasks: state.tasks.map(t => 
      t.id === taskId ? { ...t, status: newStatus } : t
    )
  }))
}))
\`\`\`

**نتيجة اليوم الثالث:**
- CRUD كامل للمهام والمشاريع
- State management جاهز
- API layer منظم

## اليوم الرابع: واجهة Kanban

### لوحة Kanban مع Drag & Drop

هذا كان الجزء الأكثر تحدياً. استخدمت dnd-kit:

\`\`\`typescript
// components/KanbanBoard.tsx
export function KanbanBoard({ tasks }: { tasks: Task[] }) {
  const [activeId, setActiveId] = useState<string | null>(null)
  
  const columns: Column[] = [
    { id: 'todo', title: 'قيد الانتظار' },
    { id: 'in-progress', title: 'قيد التنفيذ' },
    { id: 'done', title: 'مكتمل' }
  ]

  return (
    <DndContext
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      <div className="flex gap-4">
        {columns.map(column => (
          <KanbanColumn 
            key={column.id}
            column={column}
            tasks={tasks.filter(t => t.status === column.id)}
          />
        ))}
      </div>
    </DndContext>
  )
}
\`\`\`

### تحديثات Real-time

\`\`\`typescript
// hooks/useRealtimeTasks.ts
export function useRealtimeTasks(projectId: string) {
  const { setTasks, addTask } = useTaskStore()
  
  useEffect(() => {
    const channel = supabase
      .channel('tasks')
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'tasks' },
        (payload) => {
          if (payload.eventType === 'INSERT') {
            addTask(payload.new as Task)
          }
          // Handle UPDATE, DELETE...
        }
      )
      .subscribe()

    return () => { supabase.removeChannel(channel) }
  }, [projectId])
}
\`\`\`

**نتيجة اليوم الرابع:**
- لوحة Kanban تعمل
- سحب وإفلات سلس
- تحديثات فورية

## اليوم الخامس: الدفع والاشتراكات

### تكامل Stripe

\`\`\`typescript
// app/api/stripe/route.ts
export async function POST(req: Request) {
  const { priceId } = await req.json()
  
  const session = await stripe.checkout.sessions.create({
    mode: 'subscription',
    payment_method_types: ['card'],
    line_items: [{ price: priceId, quantity: 1 }],
    success_url: \`\${process.env.URL}/dashboard?success=true\`,
    cancel_url: \`\${process.env.URL}/pricing\`,
  })

  return Response.json({ url: session.url })
}
\`\`\`

### الخطط

| الخطة | السعر | الميزات |
|------|------|---------|
| Free | $0 | 1 مشروع، 3 أعضاء |
| Pro | $9/شهر | مشاريع غير محدودة، 10 أعضاء |
| Team | $29/شهر | كل شيء غير محدود |

**نتيجة اليوم الخامس:**
- صفحة تسعير
- Checkout يعمل
- Webhooks للاشتراكات

## اليوم السادس: التحسينات والتجميل

### تحسينات UX

- إضافة Skeleton loaders
- تحسين الـ animations
- إضافة Toast notifications
- Dark mode

### التحسينات التقنية

\`\`\`typescript
// Optimistic updates للسرعة
const moveTask = async (taskId: string, newStatus: Status) => {
  // تحديث فوري في UI
  useTaskStore.getState().moveTask(taskId, newStatus)
  
  // تحديث في الخلفية
  try {
    await updateTaskStatus(taskId, newStatus)
  } catch (error) {
    // Rollback في حالة الفشل
    useTaskStore.getState().moveTask(taskId, oldStatus)
    toast.error('فشل في تحديث المهمة')
  }
}
\`\`\`

**نتيجة اليوم السادس:**
- تجربة مستخدم سلسة
- أداء ممتاز
- تصميم جذاب

## اليوم السابع: الإطلاق

### قائمة التحقق قبل الإطلاق

- [ ] اختبار المسارات الحرجة
- [ ] إعداد analytics (Vercel Analytics)
- [ ] صفحة Landing page
- [ ] شروط الخدمة وسياسة الخصوصية
- [ ] إعداد custom domain
- [ ] نشر على Vercel

### النشر

\`\`\`bash
# ربط مع Vercel
vercel link

# نشر Production
vercel --prod

# إضافة النطاق
vercel domains add taskflow.app
\`\`\`

## النتائج والدروس المستفادة

### الإحصائيات

- **إجمالي الوقت**: ~40 ساعة
- **عدد الملفات**: 67 ملف
- **أسطر الكود**: ~4,500 سطر
- **التكلفة**: $32

### ما نجح بشكل ممتاز

1. **Cursor Composer**: بنى ملفات كاملة بدقة عالية
2. **Supabase**: وفّر أيام من بناء الـ Backend
3. **v0.dev**: سرّع بناء المكونات الأولية
4. **التخطيط المسبق**: تحديد MVP مبكراً وفّر الكثير من الوقت

### ما كان صعباً

1. **Drag & Drop**: احتاج ضبطاً دقيقاً
2. **Real-time sync**: Edge cases كثيرة
3. **Stripe webhooks**: التصحيح محلياً صعب

### نصائح للمشاريع المشابهة

1. **ابدأ بـ MVP حقيقي**: 3-5 ميزات فقط
2. **استخدم SaaS كامل**: Supabase, Clerk, إلخ
3. **لا تبني ما يمكنك شراؤه**: وقتك أغلى
4. **اختبر مبكراً**: لا تنتظر اليوم الأخير
5. **وثّق قراراتك**: ستشكر نفسك لاحقاً

## الخلاصة

بناء SaaS في أسبوع ممكن فعلاً مع الأدوات الحديثة. المفتاح ليس السرعة، بل **الاختيارات الذكية**:

- اختر المشكلة الصحيحة
- حدد MVP بوضوح
- استخدم أدوات مثبتة
- اترك الذكاء الاصطناعي يتولى المهام الروتينية
- ركز على القيمة للمستخدم

TaskFlow الآن يخدم مستخدمين حقيقيين ويحقق إيرادات. كل هذا في أسبوع وبأقل من $50. هذا هو عصر البرمجة بالإحساس!

## الروابط

- [GitHub Repo](https://github.com/example/taskflow)
- [Live Demo](https://taskflow.example.com)
- [Blog Post التفصيلي](https://blog.example.com/taskflow)
        `,
      },
    ],
  },
  {
    name: "الأمان وأفضل الممارسات (Security & Best Practices)",
    articles: [
      {
        slug: "code-review-checklist",
        title: "قائمة مراجعة الكود المُولّد بالذكاء الاصطناعي",
        section: "الأمان وأفضل الممارسات",
        content: `
# قائمة مراجعة الكود المُولّد بالذكاء الاصطناعي

الذكاء الاصطناعي يمكنه كتابة كود يعمل، لكن "يعمل" ليس كافياً. في هذا الدليل، ستتعلم كيف تراجع الكود المُولّد لضمان أنه آمن، فعال، وقابل للصيانة.

## لماذا المراجعة ضرورية؟

الذكاء الاصطناعي لديه عدة نقاط ضعف:

1. **بيانات تدريب قديمة**: قد يستخدم أساليب deprecated
2. **لا يعرف سياقك الكامل**: قد يكرر كوداً موجوداً
3. **يحاول إرضاءك**: قد يكتب كوداً خطيراً إذا طلبته
4. **Hallucinations**: قد يخترع APIs غير موجودة

## القائمة الشاملة للمراجعة

### 1. الأمان (Security) 🔒

#### SQL Injection

**❌ خطير:**
\`\`\`typescript
const query = \`SELECT * FROM users WHERE id = \${userId}\`
await db.query(query)
\`\`\`

**✅ آمن:**
\`\`\`typescript
const query = 'SELECT * FROM users WHERE id = $1'
await db.query(query, [userId])
\`\`\`

**ما تبحث عنه:**
- [ ] هل المتغيرات تُدخل مباشرة في SQL؟
- [ ] هل يُستخدم Prepared Statements؟
- [ ] هل ORM يتعامل مع الـ escaping؟

#### XSS (Cross-Site Scripting)

**❌ خطير:**
\`\`\`typescript
// React
<div dangerouslySetInnerHTML={{ __html: userInput }} />

// Vanilla JS
element.innerHTML = userInput
\`\`\`

**✅ آمن:**
\`\`\`typescript
// React (تلقائياً آمن)
<div>{userInput}</div>

// إذا احتجت HTML، استخدم sanitizer
import DOMPurify from 'dompurify'
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(content) }} />
\`\`\`

**ما تبحث عنه:**
- [ ] هل \`dangerouslySetInnerHTML\` مستخدم؟
- [ ] هل المدخلات تُعقّم (sanitize)؟
- [ ] هل الـ innerHTML يستقبل مدخلات مستخدم؟

#### Authentication & Authorization

**❌ خطير:**
\`\`\`typescript
// التحقق في الـ frontend فقط
if (user.role === 'admin') {
  showAdminPanel()
}
\`\`\`

**✅ آمن:**
\`\`\`typescript
// Server-side check
export async function GET(req: Request) {
  const user = await getUser(req)
  if (user.role !== 'admin') {
    return new Response('Forbidden', { status: 403 })
  }
  return getAdminData()
}
\`\`\`

**ما تبحث عنه:**
- [ ] هل التحقق يحدث في الـ Server؟
- [ ] هل كل endpoint محمي؟
- [ ] هل Tokens تُخزّن بأمان؟

#### Secrets & Environment Variables

**❌ خطير:**
\`\`\`typescript
const apiKey = 'sk-1234567890abcdef'
const stripe = new Stripe(apiKey)
\`\`\`

**✅ آمن:**
\`\`\`typescript
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)
\`\`\`

**ما تبحث عنه:**
- [ ] هل هناك secrets في الكود؟
- [ ] هل \`.env\` في \`.gitignore\`؟
- [ ] هل \`NEXT_PUBLIC_\` يُستخدم فقط للمتغيرات العامة؟

### 2. الأداء (Performance) ⚡

#### N+1 Queries

**❌ بطيء:**
\`\`\`typescript
const users = await db.users.findMany()
for (const user of users) {
  const posts = await db.posts.findMany({ where: { userId: user.id } })
  user.posts = posts
}
\`\`\`

**✅ سريع:**
\`\`\`typescript
const users = await db.users.findMany({
  include: { posts: true }
})
\`\`\`

**ما تبحث عنه:**
- [ ] هل هناك queries داخل loops؟
- [ ] هل يُستخدم \`include\` / \`join\`؟
- [ ] هل البيانات الكبيرة تُرقّم (paginate)؟

#### Memory Leaks

**❌ تسريب ذاكرة:**
\`\`\`typescript
useEffect(() => {
  const interval = setInterval(fetchData, 1000)
  // نسيان cleanup!
}, [])
\`\`\`

**✅ نظيف:**
\`\`\`typescript
useEffect(() => {
  const interval = setInterval(fetchData, 1000)
  return () => clearInterval(interval)
}, [])
\`\`\`

**ما تبحث عنه:**
- [ ] هل كل \`useEffect\` له cleanup؟
- [ ] هل Event Listeners تُزال؟
- [ ] هل Subscriptions تُلغى؟

#### Unnecessary Re-renders

**❌ يُعاد رندره كثيراً:**
\`\`\`typescript
function Parent() {
  const [count, setCount] = useState(0)
  
  // يُنشئ object جديد كل render
  const config = { theme: 'dark' }
  
  return <Child config={config} />
}
\`\`\`

**✅ محسّن:**
\`\`\`typescript
function Parent() {
  const [count, setCount] = useState(0)
  
  const config = useMemo(() => ({ theme: 'dark' }), [])
  
  return <Child config={config} />
}
\`\`\`

**ما تبحث عنه:**
- [ ] هل Objects/Arrays تُنشأ في render؟
- [ ] هل \`useMemo\` / \`useCallback\` مستخدم عند الحاجة؟
- [ ] هل المكونات الثقيلة تستخدم \`memo\`؟

### 3. جودة الكود (Code Quality) 📝

#### Error Handling

**❌ ناقص:**
\`\`\`typescript
const data = await fetch('/api/data').then(r => r.json())
\`\`\`

**✅ كامل:**
\`\`\`typescript
try {
  const response = await fetch('/api/data')
  if (!response.ok) {
    throw new Error(\`HTTP error! status: \${response.status}\`)
  }
  const data = await response.json()
  return data
} catch (error) {
  console.error('Failed to fetch data:', error)
  throw error // أو تعامل معه
}
\`\`\`

**ما تبحث عنه:**
- [ ] هل الأخطاء تُلتقط؟
- [ ] هل رسائل الخطأ مفيدة؟
- [ ] هل Errors تُسجّل للـ debugging؟

#### TypeScript Types

**❌ ضعيف:**
\`\`\`typescript
function processData(data: any): any {
  return data.items.map((item: any) => item.name)
}
\`\`\`

**✅ قوي:**
\`\`\`typescript
interface Item {
  id: string
  name: string
}

interface Data {
  items: Item[]
}

function processData(data: Data): string[] {
  return data.items.map(item => item.name)
}
\`\`\`

**ما تبحث عنه:**
- [ ] هل \`any\` مستخدم بدون سبب؟
- [ ] هل الـ Types معرّفة بوضوح؟
- [ ] هل null/undefined يُتعامل معه؟

#### Code Duplication

**ما تبحث عنه:**
- [ ] هل نفس المنطق متكرر؟
- [ ] هل يمكن استخراج دالة مشتركة؟
- [ ] هل هناك مكونات يمكن إعادة استخدامها؟

### 4. التوافق (Compatibility) 🔄

#### Browser Compatibility

**❌ قد لا يعمل:**
\`\`\`typescript
// Optional chaining قد لا يعمل في متصفحات قديمة
const name = user?.profile?.name
\`\`\`

**✅ آمن:**
\`\`\`typescript
// تأكد من إعدادات Babel/TypeScript target
// أو استخدم polyfills عند الحاجة
\`\`\`

**ما تبحث عنه:**
- [ ] ما هو الـ target في tsconfig؟
- [ ] هل المتصفحات المستهدفة مدعومة؟
- [ ] هل الـ APIs المستخدمة متوافقة؟

#### API Versioning

**ما تبحث عنه:**
- [ ] هل الـ API endpoints صحيحة؟
- [ ] هل الـ packages محدّثة؟
- [ ] هل هناك deprecated methods؟

## سير عمل المراجعة

### الخطوة 1: قراءة سريعة (2 دقائق)

- هل الكود منطقي؟
- هل البنية واضحة؟
- هل هناك red flags واضحة؟

### الخطوة 2: فحص الأمان (5 دقائق)

- ابحث عن \`dangerouslySetInnerHTML\`
- ابحث عن SQL/query strings
- تحقق من environment variables
- تحقق من auth checks

### الخطوة 3: فحص الأداء (3 دقائق)

- ابحث عن queries في loops
- تحقق من useEffect cleanup
- ابحث عن re-renders غير ضرورية

### الخطوة 4: فحص الجودة (5 دقائق)

- تحقق من error handling
- راجع TypeScript types
- ابحث عن code duplication

### الخطوة 5: اختبار عملي (5 دقائق)

- شغّل الكود
- جرب edge cases
- تحقق من الأخطاء في console

## أدوات المساعدة

### ESLint Rules

\`\`\`json
{
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "react-hooks/exhaustive-deps": "warn",
    "no-console": "warn"
  }
}
\`\`\`

### Automated Checks

\`\`\`bash
# Type checking
npx tsc --noEmit

# Linting
npm run lint

# Security audit
npm audit
\`\`\`

## ملخص القائمة السريعة

### قبل كل Merge:

- [ ] **أمان**: لا SQL injection, لا XSS, لا secrets
- [ ] **أداء**: لا N+1, cleanup موجود, لا re-renders زائدة
- [ ] **جودة**: errors handled, types صحيحة, لا تكرار
- [ ] **اختبار**: يعمل فعلاً, edge cases OK

## الخلاصة

الذكاء الاصطناعي مساعد قوي، لكنه ليس بديلاً عن المراجعة البشرية. خصص 10-15 دقيقة لمراجعة كل قطعة كود مهمة. مع الوقت، ستصبح هذه العملية طبيعية وسريعة.

تذكر: الكود السيئ قد يعمل اليوم، لكنه سيسبب مشاكل غداً. استثمر في الجودة من البداية!
        `,
      },
    ],
  },
  {
    name: "المجتمع والموارد (Community & Resources)",
    articles: [
      {
        slug: "contribution-guide",
        title: "دليل المساهمة في Vibe Wiki",
        section: "المجتمع والموارد",
        content: `
# دليل المساهمة في Vibe Wiki

مرحباً بك في مجتمع Vibe Wiki! هذا الدليل سيساعدك على المساهمة في تطوير هذه الموسوعة العربية للبرمجة بمساعدة الذكاء الاصطناعي.

## لماذا نحتاج مساهمتك؟

Vibe Wiki هو مشروع مفتوح المصدر يهدف لتوفير محتوى عربي عالي الجودة عن البرمجة الحديثة. نحتاج:

- **كتّاب محتوى**: لإنشاء مقالات جديدة
- **مترجمين**: لتعريب المصطلحات التقنية
- **مراجعين**: للتحقق من دقة المحتوى
- **مطورين**: لتحسين الموقع تقنياً
- **مصممين**: لتحسين تجربة المستخدم

## البداية السريعة

### 1. إعداد البيئة

\`\`\`bash
# Fork المشروع على GitHub أولاً
# ثم clone نسختك

git clone https://github.com/YOUR_USERNAME/vibe-wiki.git
cd vibe-wiki

# تثبيت المتطلبات
npm install

# تشغيل بيئة التطوير
npm run dev
\`\`\`

### 2. هيكل المشروع

\`\`\`
vibe-wiki/
├── src/
│   ├── app/                 # صفحات Next.js
│   ├── components/          # مكونات React
│   ├── data/
│   │   └── wiki-content.ts  # 📝 محتوى المقالات
│   └── lib/                 # أدوات مساعدة
├── public/                  # ملفات ثابتة
└── package.json
\`\`\`

### 3. إضافة مقالة جديدة

المقالات موجودة في \`src/data/wiki-content.ts\`. كل مقالة تتبع هذا الشكل:

\`\`\`typescript
{
  slug: "article-url-slug",
  title: "عنوان المقالة بالعربية",
  section: "اسم القسم",
  content: \`
# عنوان المقالة

المحتوى هنا بصيغة Markdown...

## عنوان فرعي

النص والشرح...

### أمثلة الكود

\\\`\\\`\\\`typescript
const example = "code here"
\\\`\\\`\\\`
  \`
}
\`\`\`

## قواعد المحتوى

### الأسلوب الكتابي

1. **استخدم العربية الفصحى البسيطة**
   - تجنب التعقيد اللغوي
   - اكتب كأنك تشرح لصديق

2. **المصطلحات التقنية**
   - استخدم المصطلح الإنجليزي مع شرح عربي
   - مثال: "المستودع (Repository)"
   - لا تترجم ترجمة حرفية مُربكة

3. **الأمثلة العملية**
   - كل مفهوم يحتاج مثالاً
   - استخدم أمثلة واقعية وليست مجردة
   - الكود يجب أن يعمل فعلاً

4. **الطول المناسب**
   - الحد الأدنى: 800 كلمة
   - ركز على العمق وليس الطول
   - لا حشو

### تنسيق Markdown

\`\`\`markdown
# عنوان رئيسي (H1) - واحد فقط في المقالة

## عنوان قسم (H2)

### عنوان فرعي (H3)

**نص عريض** للتأكيد

\`كود مضمن\` للأوامر القصيرة

\\\`\\\`\\\`typescript
// كود متعدد الأسطر
const code = "example"
\\\`\\\`\\\`

- قائمة نقطية
- عنصر آخر

1. قائمة مرقمة
2. عنصر آخر

| عمود 1 | عمود 2 |
|--------|--------|
| بيانات | بيانات |

> اقتباس أو ملاحظة مهمة
\`\`\`

## عملية المساهمة

### 1. إنشاء Issue

قبل البدء بعمل كبير، افتح Issue لمناقشة الفكرة:

\`\`\`markdown
العنوان: [مقالة جديدة] اسم المقالة

## الوصف
شرح مختصر للمقالة المقترحة

## المحتوى المتوقع
- النقطة الأولى
- النقطة الثانية
- النقطة الثالثة

## لماذا هذه المقالة مهمة؟
شرح القيمة المضافة
\`\`\`

### 2. إنشاء Branch

\`\`\`bash
# تحديث main
git checkout main
git pull upstream main

# إنشاء branch جديد
git checkout -b article/your-article-name

# أو للإصلاحات
git checkout -b fix/issue-description
\`\`\`

### 3. كتابة التغييرات

\`\`\`bash
# تعديل الملفات
# ...

# تأكد من أن كل شيء يعمل
npm run build

# أضف التغييرات
git add .
git commit -m "إضافة مقالة: اسم المقالة"
\`\`\`

### 4. إنشاء Pull Request

\`\`\`bash
# ارفع التغييرات
git push origin article/your-article-name
\`\`\`

ثم اذهب لـ GitHub وأنشئ Pull Request مع:

\`\`\`markdown
## الوصف
شرح التغييرات

## نوع التغيير
- [ ] مقالة جديدة
- [ ] تعديل مقالة موجودة
- [ ] إصلاح خطأ
- [ ] تحسين تقني

## قائمة التحقق
- [ ] المحتوى بالعربية
- [ ] الكود يعمل
- [ ] لا أخطاء في البناء
- [ ] راجعت التنسيق
\`\`\`

## معايير القبول

### للمقالات الجديدة

| المعيار | الوصف |
|---------|-------|
| الأصالة | محتوى أصلي وليس منسوخاً |
| الدقة | المعلومات صحيحة ومحدثة |
| الوضوح | سهل الفهم للمبتدئين |
| العملية | أمثلة تعمل فعلاً |
| الطول | 800+ كلمة |
| التنسيق | Markdown صحيح |

### للإصلاحات التقنية

| المعيار | الوصف |
|---------|-------|
| لا أخطاء | \`npm run build\` ينجح |
| الاختبارات | لا اختبارات فاشلة |
| التوافق | يعمل على المتصفحات الرئيسية |
| الأداء | لا تأثير سلبي على السرعة |

## نصائح للمساهمين

### للمبتدئين

1. **ابدأ صغيراً**: صحح خطأ إملائياً أو حسّن جملة
2. **اقرأ المقالات الموجودة**: افهم الأسلوب
3. **اسأل**: لا تخجل من طرح الأسئلة

### للكتّاب

1. **ابحث جيداً**: تأكد من دقة المعلومات
2. **جرب الكود**: لا تنسخ كوداً لم تختبره
3. **فكر في القارئ**: ماذا يحتاج أن يعرف؟

### للمطورين

1. **اتبع الأنماط الموجودة**: لا تخترع أسلوباً جديداً
2. **وثّق تغييراتك**: اكتب commit messages واضحة
3. **اختبر محلياً**: قبل رفع الكود

## التواصل

### القنوات الرسمية

- **GitHub Issues**: للمشاكل والاقتراحات
- **GitHub Discussions**: للنقاشات العامة
- **Discord**: للتواصل السريع (الرابط في README)

### الإبلاغ عن مشاكل

إذا وجدت خطأً في مقالة:

1. افتح Issue جديد
2. حدد المقالة بالضبط
3. اشرح الخطأ بوضوح
4. اقترح التصحيح إن أمكن

## الاعتراف بالمساهمين

نقدر كل مساهمة! المساهمون يظهرون في:

- قائمة المساهمين في README
- صفحة "شكر خاص" في الموقع
- تاريخ Git للمشروع

## الخطوات التالية

الآن بعد أن فهمت كيفية المساهمة:

1. ✅ Fork المشروع
2. ✅ اقرأ المقالات الموجودة
3. ✅ اختر مهمة من Issues
4. ✅ ابدأ العمل!

كل مساهمة مهما كانت صغيرة تحدث فرقاً. نحن نبني معاً أفضل مورد عربي للبرمجة الحديثة!

## الأسئلة الشائعة

**س: هل أحتاج خبرة برمجية للمساهمة؟**
ج: لا! يمكنك المساهمة بتصحيح الأخطاء اللغوية أو اقتراح مواضيع.

**س: كم من الوقت تستغرق مراجعة PR؟**
ج: عادة 2-5 أيام عمل.

**س: هل يمكنني الكتابة عن موضوع غير موجود؟**
ج: بالتأكيد! افتح Issue أولاً لمناقشة الفكرة.

**س: ماذا لو رُفض PR؟**
ج: سنشرح السبب ونساعدك في التحسين. لا تيأس!

شكراً لاهتمامك بالمساهمة! 🎉
        `,
      },
    ],
  },
  {
    name: "الذكاء الاصطناعي المخصص (Custom AI)",
    articles: [
      {
        slug: "rag-systems",
        title: "أنظمة RAG: دليلك الشامل للبحث المعزز بالتوليد",
        section: "الذكاء الاصطناعي المخصص",
        content: `
# أنظمة RAG: دليلك الشامل للبحث المعزز بالتوليد

**RAG** (Retrieval-Augmented Generation) هي تقنية تجمع بين قوة البحث في قواعد المعرفة وقدرة نماذج اللغة على التوليد. في هذا الدليل، ستفهم المفهوم وتتعلم كيف تبني نظام RAG بسيط.

## ما هو RAG؟

تخيل أنك تسأل ChatGPT سؤالاً عن مشروعك الخاص. لن يعرف الإجابة لأنه لم يُدرَّب على كودك. هنا يأتي دور RAG:

1. **البحث (Retrieval)**: البحث في مستنداتك عن المعلومات ذات الصلة
2. **التعزيز (Augmentation)**: إضافة هذه المعلومات لسياق السؤال
3. **التوليد (Generation)**: الذكاء الاصطناعي يجيب بناءً على المعلومات المقدمة

### مثال عملي

**بدون RAG:**
\`\`\`
سؤال: ما هي الدالة المسؤولة عن المصادقة في مشروعي؟
جواب: لا أعرف تفاصيل مشروعك.
\`\`\`

**مع RAG:**
\`\`\`
سؤال: ما هي الدالة المسؤولة عن المصادقة في مشروعي؟
[النظام يبحث ويجد auth.ts]
جواب: الدالة authenticateUser في ملف auth.ts هي المسؤولة.
      إليك شرحها: ...
\`\`\`

## لماذا RAG مهم؟

| المشكلة | الحل بـ RAG |
|---------|-------------|
| النماذج لا تعرف بياناتك | تزويدها بالسياق |
| المعلومات قديمة | تحديث قاعدة المعرفة |
| الهلوسة (Hallucination) | إجابات مبنية على حقائق |
| تكلفة إعادة التدريب | لا حاجة لتدريب جديد |

## المكونات الأساسية

### 1. قاعدة المعرفة (Knowledge Base)

المستندات التي تريد البحث فيها:
- ملفات الكود
- التوثيق
- ملفات PDF
- صفحات ويب

### 2. نظام الـ Embeddings

تحويل النصوص لمتجهات رقمية (vectors) تمثل المعنى:

\`\`\`typescript
// مثال تبسيطي
"البرمجة ممتعة" → [0.2, 0.8, -0.1, ...]
"الكود رائع" → [0.3, 0.7, -0.2, ...]  // قريب!
"الطقس جميل" → [-0.5, 0.1, 0.9, ...]  // بعيد!
\`\`\`

### 3. قاعدة بيانات المتجهات (Vector Database)

مكان تخزين الـ embeddings والبحث فيها:
- **Pinecone**: سحابي، سهل الاستخدام
- **Weaviate**: مفتوح المصدر
- **Chroma**: خفيف، للتجارب
- **Supabase pgvector**: مدمج مع Postgres

### 4. نموذج اللغة (LLM)

النموذج الذي سيولد الإجابة:
- OpenAI GPT-4
- Claude
- Llama (محلي)

## بناء نظام RAG بسيط

### الخطوة 1: تجهيز البيئة

\`\`\`bash
npm install openai @pinecone-database/pinecone langchain
\`\`\`

### الخطوة 2: تحويل المستندات لـ Embeddings

\`\`\`typescript
import { OpenAIEmbeddings } from 'langchain/embeddings/openai'
import { Document } from 'langchain/document'

const embeddings = new OpenAIEmbeddings({
  openAIApiKey: process.env.OPENAI_API_KEY
})

// تقسيم المستند لقطع صغيرة
function splitDocument(text: string, chunkSize = 500): string[] {
  const chunks: string[] = []
  let currentChunk = ''
  
  const sentences = text.split('. ')
  for (const sentence of sentences) {
    if ((currentChunk + sentence).length > chunkSize) {
      chunks.push(currentChunk.trim())
      currentChunk = sentence
    } else {
      currentChunk += sentence + '. '
    }
  }
  if (currentChunk) chunks.push(currentChunk.trim())
  
  return chunks
}

// تحويل النص لـ embedding
async function getEmbedding(text: string): Promise<number[]> {
  const result = await embeddings.embedQuery(text)
  return result
}
\`\`\`

### الخطوة 3: تخزين في Vector Database

\`\`\`typescript
import { Pinecone } from '@pinecone-database/pinecone'

const pinecone = new Pinecone({
  apiKey: process.env.PINECONE_API_KEY!
})

const index = pinecone.Index('my-knowledge-base')

async function storeDocuments(documents: Document[]) {
  for (const doc of documents) {
    const chunks = splitDocument(doc.content)
    
    for (let i = 0; i < chunks.length; i++) {
      const embedding = await getEmbedding(chunks[i])
      
      await index.upsert([{
        id: \`\${doc.id}-chunk-\${i}\`,
        values: embedding,
        metadata: {
          text: chunks[i],
          source: doc.source,
          title: doc.title
        }
      }])
    }
  }
}
\`\`\`

### الخطوة 4: البحث عن المعلومات ذات الصلة

\`\`\`typescript
async function searchKnowledgeBase(query: string, topK = 5) {
  const queryEmbedding = await getEmbedding(query)
  
  const results = await index.query({
    vector: queryEmbedding,
    topK,
    includeMetadata: true
  })
  
  return results.matches.map(match => ({
    text: match.metadata?.text,
    source: match.metadata?.source,
    score: match.score
  }))
}
\`\`\`

### الخطوة 5: توليد الإجابة

\`\`\`typescript
import OpenAI from 'openai'

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
})

async function generateAnswer(question: string) {
  // 1. البحث عن المعلومات ذات الصلة
  const relevantDocs = await searchKnowledgeBase(question)
  
  // 2. بناء السياق
  const context = relevantDocs
    .map(doc => \`المصدر: \${doc.source}\\n\${doc.text}\`)
    .join('\\n\\n---\\n\\n')
  
  // 3. بناء البرومبت
  const prompt = \`استخدم المعلومات التالية للإجابة على السؤال.
إذا لم تجد الإجابة في المعلومات المقدمة، قل ذلك.

المعلومات:
\${context}

السؤال: \${question}

الإجابة:\`

  // 4. توليد الإجابة
  const response = await openai.chat.completions.create({
    model: 'gpt-4',
    messages: [{ role: 'user', content: prompt }],
    temperature: 0.7
  })
  
  return {
    answer: response.choices[0].message.content,
    sources: relevantDocs.map(d => d.source)
  }
}
\`\`\`

### الخطوة 6: الاستخدام

\`\`\`typescript
// مثال استخدام
const result = await generateAnswer(
  "كيف أضيف مستخدم جديد في النظام؟"
)

console.log("الإجابة:", result.answer)
console.log("المصادر:", result.sources)
\`\`\`

## تحسينات متقدمة

### 1. إعادة الترتيب (Re-ranking)

\`\`\`typescript
// استخدام نموذج لإعادة ترتيب النتائج حسب الصلة
async function rerankResults(query: string, results: SearchResult[]) {
  const prompt = \`رتب هذه النتائج حسب صلتها بالسؤال: "\${query}"
  
النتائج:
\${results.map((r, i) => \`\${i + 1}. \${r.text.substring(0, 200)}\`).join('\\n')}

أعد الترتيب كأرقام (الأكثر صلة أولاً):\`

  // ... استخدم LLM لإعادة الترتيب
}
\`\`\`

### 2. الأسئلة المتعددة (Multi-Query)

\`\`\`typescript
// توليد عدة صياغات للسؤال للبحث الأشمل
async function generateQueries(originalQuery: string) {
  const prompt = \`أعد صياغة هذا السؤال بثلاث طرق مختلفة:
"\${originalQuery}"

الصياغات:\`

  // ... توليد صياغات متعددة
  // ثم البحث بكل صياغة ودمج النتائج
}
\`\`\`

### 3. التقييم الذاتي

\`\`\`typescript
// تقييم جودة الإجابة
async function evaluateAnswer(question: string, answer: string, context: string) {
  const prompt = \`قيّم هذه الإجابة:
  
السؤال: \${question}
السياق المتاح: \${context}
الإجابة: \${answer}

هل الإجابة:
1. دقيقة؟
2. مبنية على السياق؟
3. كاملة؟

التقييم (1-10):\`

  // ... الحصول على تقييم
}
\`\`\`

## متى تستخدم RAG؟

### استخدم RAG عندما:

✅ لديك مستندات خاصة تريد الاستفادة منها
✅ البيانات تتغير بشكل متكرر
✅ تحتاج إجابات موثوقة ومصدّرة
✅ ميزانية محدودة (أرخص من fine-tuning)
✅ تريد نظاماً قابلاً للتحديث بسهولة

### لا تستخدم RAG عندما:

❌ المهمة بسيطة ولا تحتاج سياق
❌ البيانات قليلة جداً (يمكن وضعها في البرومبت)
❌ تحتاج سرعة فائقة (RAG يضيف latency)

## أدوات وخدمات جاهزة

| الأداة | الوصف | السعر |
|-------|-------|-------|
| LangChain | إطار عمل Python/JS لبناء RAG | مجاني |
| LlamaIndex | متخصص في RAG | مجاني |
| Vercel AI SDK | تكامل سهل مع Next.js | مجاني |
| Pinecone | قاعدة بيانات متجهات سحابية | مجاني للبداية |
| Chroma | قاعدة بيانات متجهات محلية | مجاني |

## الخلاصة

RAG هي تقنية قوية تتيح لك بناء تطبيقات ذكاء اصطناعي تفهم بياناتك الخاصة. المفاتيح الأساسية:

1. **قسّم المستندات** لقطع مناسبة الحجم
2. **اختر embedding model** جيد
3. **استخدم vector database** مناسب
4. **صمم البرومبت** بعناية
5. **قيّم النتائج** باستمرار

ابدأ بنظام بسيط، ثم حسّن تدريجياً بناءً على الاستخدام الفعلي!
        `,
      },
    ],
  },
  {
    name: "مشاريع عملية (Hands-On Projects)",
    articles: [
      {
        slug: "project-chatbot",
        title: "مشروع: بناء Chatbot ذكي من الصفر",
        section: "مشاريع عملية",
        content: `
# مشروع: بناء Chatbot ذكي من الصفر

في هذا المشروع العملي، ستبني chatbot كامل الوظائف باستخدام Next.js و OpenAI API. سنمر بكل خطوة من الفكرة إلى التشغيل.

## ما ستبنيه

**ChatPal** - مساعد ذكي يمكنه:
- الرد على الأسئلة العامة
- تذكر سياق المحادثة
- التنسيق الجميل للرسائل (Markdown)
- تجربة مستخدم سلسة مع streaming

## المتطلبات

- Node.js 18+
- حساب OpenAI مع API key
- معرفة أساسية بـ React و TypeScript

## الخطوة 1: إنشاء المشروع

\`\`\`bash
# إنشاء مشروع Next.js جديد
npx create-next-app@latest chatpal --typescript --tailwind --app

cd chatpal

# تثبيت المكتبات اللازمة
npm install openai ai react-markdown
\`\`\`

## الخطوة 2: إعداد المتغيرات البيئية

أنشئ ملف \`.env.local\`:

\`\`\`env
OPENAI_API_KEY=sk-your-api-key-here
\`\`\`

## الخطوة 3: إنشاء Route Handler للـ API

أنشئ ملف \`app/api/chat/route.ts\`:

\`\`\`typescript
import OpenAI from 'openai'
import { OpenAIStream, StreamingTextResponse } from 'ai'

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
})

export const runtime = 'edge'

export async function POST(req: Request) {
  const { messages } = await req.json()

  // إضافة system message لتحديد شخصية البوت
  const systemMessage = {
    role: 'system' as const,
    content: \`أنت مساعد ذكي ودود اسمه ChatPal.
تجيب بالعربية دائماً إلا إذا طُلب منك غير ذلك.
تستخدم تنسيق Markdown لتحسين قراءة ردودك.
إذا كتب المستخدم كوداً، ساعده في تحسينه واشرح اقتراحاتك.\`
  }

  const response = await openai.chat.completions.create({
    model: 'gpt-4o',
    stream: true,
    messages: [systemMessage, ...messages],
    temperature: 0.7,
    max_tokens: 2000
  })

  // تحويل الـ response لـ stream
  const stream = OpenAIStream(response)
  
  return new StreamingTextResponse(stream)
}
\`\`\`

## الخطوة 4: إنشاء مكون الـ Chat

أنشئ ملف \`components/Chat.tsx\`:

\`\`\`typescript
'use client'

import { useChat } from 'ai/react'
import { useRef, useEffect } from 'react'
import ReactMarkdown from 'react-markdown'

export function Chat() {
  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat()
  const messagesEndRef = useRef<HTMLDivElement>(null)

  // التمرير التلقائي للأسفل
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  return (
    <div className="flex flex-col h-screen max-w-4xl mx-auto">
      {/* Header */}
      <header className="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-4 shadow-lg">
        <h1 className="text-2xl font-bold text-center">🤖 ChatPal</h1>
        <p className="text-center text-blue-100 text-sm">مساعدك الذكي</p>
      </header>

      {/* Messages Container */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-gray-50">
        {messages.length === 0 && (
          <div className="text-center text-gray-500 mt-20">
            <p className="text-6xl mb-4">👋</p>
            <p className="text-xl">مرحباً! كيف يمكنني مساعدتك اليوم؟</p>
          </div>
        )}

        {messages.map((message) => (
          <div
            key={message.id}
            className={\`flex \${message.role === 'user' ? 'justify-end' : 'justify-start'}\`}
          >
            <div
              className={\`max-w-[80%] rounded-2xl px-4 py-3 \${
                message.role === 'user'
                  ? 'bg-blue-600 text-white rounded-br-md'
                  : 'bg-white text-gray-800 shadow-md rounded-bl-md'
              }\`}
            >
              {message.role === 'assistant' ? (
                <ReactMarkdown
                  className="prose prose-sm max-w-none"
                  components={{
                    code: ({ className, children }) => {
                      const isInline = !className
                      return isInline ? (
                        <code className="bg-gray-100 px-1 rounded text-sm">
                          {children}
                        </code>
                      ) : (
                        <pre className="bg-gray-900 text-gray-100 p-3 rounded-lg overflow-x-auto">
                          <code>{children}</code>
                        </pre>
                      )
                    }
                  }}
                >
                  {message.content}
                </ReactMarkdown>
              ) : (
                <p>{message.content}</p>
              )}
            </div>
          </div>
        ))}

        {isLoading && (
          <div className="flex justify-start">
            <div className="bg-white rounded-2xl px-4 py-3 shadow-md">
              <div className="flex space-x-2">
                <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" />
                <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce delay-100" />
                <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce delay-200" />
              </div>
            </div>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Input Form */}
      <form onSubmit={handleSubmit} className="p-4 bg-white border-t">
        <div className="flex gap-2">
          <input
            type="text"
            value={input}
            onChange={handleInputChange}
            placeholder="اكتب رسالتك هنا..."
            className="flex-1 p-3 border rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isLoading}
          />
          <button
            type="submit"
            disabled={isLoading || !input.trim()}
            className="px-6 py-3 bg-blue-600 text-white rounded-xl hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            إرسال
          </button>
        </div>
      </form>
    </div>
  )
}
\`\`\`

## الخطوة 5: تحديث الصفحة الرئيسية

عدّل ملف \`app/page.tsx\`:

\`\`\`typescript
import { Chat } from '@/components/Chat'

export default function Home() {
  return <Chat />
}
\`\`\`

## الخطوة 6: تحسين الـ Global Styles

عدّل ملف \`app/globals.css\`:

\`\`\`css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* تحسينات للـ RTL */
html {
  direction: rtl;
}

/* تحسين الـ animations */
.delay-100 {
  animation-delay: 0.1s;
}

.delay-200 {
  animation-delay: 0.2s;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #a1a1a1;
}
\`\`\`

## الخطوة 7: التشغيل والاختبار

\`\`\`bash
npm run dev
\`\`\`

افتح http://localhost:3000 وجرب الدردشة!

## تحسينات إضافية

### 1. حفظ المحادثات في LocalStorage

\`\`\`typescript
// في Chat.tsx
import { useEffect } from 'react'

// حفظ المحادثات
useEffect(() => {
  if (messages.length > 0) {
    localStorage.setItem('chatHistory', JSON.stringify(messages))
  }
}, [messages])

// استرجاع المحادثات عند التحميل
useEffect(() => {
  const saved = localStorage.getItem('chatHistory')
  if (saved) {
    // استخدم setMessages إذا كان متاحاً
  }
}, [])
\`\`\`

### 2. إضافة أزرار سريعة

\`\`\`typescript
const quickPrompts = [
  'اشرح لي مفهوم الـ API',
  'كيف أتعلم React؟',
  'ساعدني في تصحيح كود',
]

// في الـ JSX
{messages.length === 0 && (
  <div className="flex flex-wrap gap-2 justify-center mt-4">
    {quickPrompts.map((prompt) => (
      <button
        key={prompt}
        onClick={() => handleSubmit({ preventDefault: () => {} } as any)}
        className="px-4 py-2 bg-white border rounded-full hover:bg-gray-50"
      >
        {prompt}
      </button>
    ))}
  </div>
)}
\`\`\`

### 3. إضافة زر مسح المحادثة

\`\`\`typescript
// استخدم reload من useChat
const { messages, input, handleInputChange, handleSubmit, isLoading, reload } = useChat()

// زر المسح
<button
  onClick={() => window.location.reload()}
  className="text-gray-500 hover:text-red-500"
>
  🗑️ محادثة جديدة
</button>
\`\`\`

## النشر على Vercel

\`\`\`bash
# تثبيت Vercel CLI
npm i -g vercel

# تسجيل الدخول
vercel login

# النشر
vercel

# إضافة Environment Variables في Vercel Dashboard
# OPENAI_API_KEY = your-key
\`\`\`

## التكلفة المتوقعة

| الاستخدام | التكلفة التقريبية |
|-----------|-------------------|
| 1000 رسالة/شهر | ~$5 |
| 10000 رسالة/شهر | ~$40 |
| Vercel Hosting | مجاني (Hobby) |

## تحديات للتطوير

1. **أضف نظام تسجيل دخول** باستخدام NextAuth
2. **احفظ المحادثات في قاعدة بيانات** مثل Supabase
3. **أضف دعم الصور** باستخدام GPT-4 Vision
4. **أضف voice input** باستخدام Web Speech API
5. **اجعله RAG-powered** لقراءة مستنداتك

## الخلاصة

لقد بنيت chatbot كامل الوظائف في أقل من ساعة! المفاتيح:

- **Vercel AI SDK** يبسط الـ streaming
- **Edge Runtime** يجعله سريعاً
- **React Markdown** يحسن العرض
- **Tailwind** يجعل التصميم سريعاً

الآن لديك أساس قوي يمكنك البناء عليه. أضف الميزات التي تحتاجها وانشره للعالم!

## الكود الكامل

الكود الكامل متاح على GitHub:
[github.com/example/chatpal](https://github.com/example/chatpal)

حظاً موفقاً في مشاريعك! 🚀
        `,
      },
    ],
  },
  {
    name: "أدوات الإنتاجية (Productivity Tools)",
    articles: [
      {
        slug: "vscode-setup",
        title: "إعداد VSCode الأمثل للبرمجة بالذكاء الاصطناعي",
        section: "أدوات الإنتاجية",
        content: `
# إعداد VSCode الأمثل للبرمجة بالذكاء الاصطناعي

حتى لو كنت تستخدم Cursor أو Windsurf، فإن فهم إعداد VSCode الأمثل أساسي لأن هذه المحررات مبنية عليه. في هذا الدليل، ستتعلم كيف تحول VSCode لآلة إنتاجية.

## التثبيت والإعداد الأساسي

### تثبيت VSCode

\`\`\`bash
# macOS
brew install --cask visual-studio-code

# Windows (Chocolatey)
choco install vscode

# أو حمله من code.visualstudio.com
\`\`\`

### أول إعداد

بعد التثبيت، افتح Settings (Cmd+, أو Ctrl+,) وفعّل:

\`\`\`json
{
  "editor.fontSize": 14,
  "editor.fontFamily": "'JetBrains Mono', 'Fira Code', Consolas",
  "editor.fontLigatures": true,
  "editor.lineHeight": 1.6,
  "editor.minimap.enabled": false,
  "editor.wordWrap": "on",
  "editor.formatOnSave": true,
  "editor.tabSize": 2,
  "files.autoSave": "afterDelay",
  "files.autoSaveDelay": 1000
}
\`\`\`

## الإضافات الأساسية (Extensions)

### 1. إضافات الذكاء الاصطناعي

#### GitHub Copilot

الإضافة الأشهر للإكمال التلقائي بالذكاء الاصطناعي:

\`\`\`bash
# من Marketplace
ext install GitHub.copilot
ext install GitHub.copilot-chat
\`\`\`

**الإعدادات الموصى بها:**
\`\`\`json
{
  "github.copilot.enable": {
    "*": true,
    "markdown": true,
    "plaintext": false
  },
  "github.copilot.editor.enableAutoCompletions": true
}
\`\`\`

**اختصارات مهمة:**
- \`Tab\`: قبول الاقتراح
- \`Esc\`: رفض الاقتراح
- \`Alt+]\`: الاقتراح التالي
- \`Alt+[\`: الاقتراح السابق
- \`Ctrl+Enter\`: عرض كل الاقتراحات

#### Codeium (بديل مجاني)

\`\`\`bash
ext install Codeium.codeium
\`\`\`

إضافة ممتازة ومجانية تماماً مع إكمال تلقائي ذكي.

### 2. إضافات اللغات

#### TypeScript/JavaScript

\`\`\`bash
# ESLint للفحص
ext install dbaeumer.vscode-eslint

# Prettier للتنسيق
ext install esbenp.prettier-vscode

# Error Lens لعرض الأخطاء في السطر
ext install usernamehw.errorlens
\`\`\`

**إعدادات ESLint + Prettier:**
\`\`\`json
{
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit"
  },
  "eslint.validate": ["javascript", "typescript", "typescriptreact"]
}
\`\`\`

#### Tailwind CSS

\`\`\`bash
ext install bradlc.vscode-tailwindcss
\`\`\`

**إعدادات:**
\`\`\`json
{
  "tailwindCSS.includeLanguages": {
    "typescript": "javascript",
    "typescriptreact": "javascript"
  },
  "tailwindCSS.experimental.classRegex": [
    ["cva\\\\\\\\(([^)]*)\\\\\\\\)", "pattern"]
  ]
}
\`\`\`

### 3. إضافات الإنتاجية

#### Auto Rename Tag

\`\`\`bash
ext install formulahendry.auto-rename-tag
\`\`\`

عند تعديل tag، يتعدل الـ closing tag تلقائياً.

#### Path Intellisense

\`\`\`bash
ext install christian-kohler.path-intellisense
\`\`\`

إكمال تلقائي لمسارات الملفات.

#### Import Cost

\`\`\`bash
ext install wix.vscode-import-cost
\`\`\`

يعرض حجم كل import مباشرة في الكود.

#### GitLens

\`\`\`bash
ext install eamodio.gitlens
\`\`\`

معلومات Git متقدمة: من كتب هذا السطر؟ متى؟

### 4. إضافات التصميم

#### One Dark Pro (ثيم)

\`\`\`bash
ext install zhuangtongfa.material-theme
\`\`\`

أشهر ثيم dark مع ألوان مريحة للعين.

#### Material Icon Theme

\`\`\`bash
ext install PKief.material-icon-theme
\`\`\`

أيقونات جميلة للملفات والمجلدات.

## إعدادات متقدمة

### Settings.json الكامل

\`\`\`json
{
  // المظهر
  "workbench.colorTheme": "One Dark Pro",
  "workbench.iconTheme": "material-icon-theme",
  "workbench.startupEditor": "none",
  
  // المحرر
  "editor.fontSize": 14,
  "editor.fontFamily": "'JetBrains Mono', 'Fira Code', Consolas, monospace",
  "editor.fontLigatures": true,
  "editor.lineHeight": 1.6,
  "editor.letterSpacing": 0.5,
  "editor.cursorBlinking": "smooth",
  "editor.cursorSmoothCaretAnimation": "on",
  "editor.smoothScrolling": true,
  
  // تجربة الكتابة
  "editor.minimap.enabled": false,
  "editor.wordWrap": "on",
  "editor.formatOnSave": true,
  "editor.formatOnPaste": true,
  "editor.tabSize": 2,
  "editor.insertSpaces": true,
  "editor.detectIndentation": false,
  "editor.linkedEditing": true,
  "editor.bracketPairColorization.enabled": true,
  "editor.guides.bracketPairs": true,
  
  // الملفات
  "files.autoSave": "afterDelay",
  "files.autoSaveDelay": 1000,
  "files.trimTrailingWhitespace": true,
  "files.insertFinalNewline": true,
  
  // الطرفية
  "terminal.integrated.fontSize": 13,
  "terminal.integrated.fontFamily": "'JetBrains Mono', monospace",
  "terminal.integrated.defaultProfile.osx": "zsh",
  
  // Git
  "git.enableSmartCommit": true,
  "git.confirmSync": false,
  "git.autofetch": true,
  
  // Copilot
  "github.copilot.enable": {
    "*": true,
    "yaml": true,
    "markdown": true
  },
  
  // TypeScript
  "typescript.preferences.importModuleSpecifier": "relative",
  "typescript.suggest.autoImports": true,
  "typescript.updateImportsOnFileMove.enabled": "always",
  
  // تنسيق
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "[javascript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[typescriptreact]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[json]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  
  // ESLint
  "eslint.validate": [
    "javascript",
    "typescript",
    "typescriptreact",
    "javascriptreact"
  ],
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit",
    "source.organizeImports": "explicit"
  }
}
\`\`\`

## اختصارات لوحة المفاتيح الأساسية

### التنقل

| الاختصار (Mac) | الاختصار (Win) | الوظيفة |
|----------------|----------------|---------|
| Cmd+P | Ctrl+P | فتح ملف سريع |
| Cmd+Shift+P | Ctrl+Shift+P | Command Palette |
| Cmd+Shift+F | Ctrl+Shift+F | بحث في كل الملفات |
| Cmd+B | Ctrl+B | إظهار/إخفاء Sidebar |
| Cmd+\` | Ctrl+\` | فتح الطرفية |
| Cmd+1/2/3 | Ctrl+1/2/3 | التنقل بين Editor Groups |

### التحرير

| الاختصار (Mac) | الاختصار (Win) | الوظيفة |
|----------------|----------------|---------|
| Cmd+D | Ctrl+D | تحديد الكلمة التالية المطابقة |
| Cmd+Shift+L | Ctrl+Shift+L | تحديد كل الكلمات المطابقة |
| Option+↑/↓ | Alt+↑/↓ | نقل السطر للأعلى/الأسفل |
| Shift+Option+↑/↓ | Shift+Alt+↑/↓ | نسخ السطر للأعلى/الأسفل |
| Cmd+/ | Ctrl+/ | تعليق/إلغاء تعليق |
| Cmd+Shift+K | Ctrl+Shift+K | حذف السطر |
| Cmd+Enter | Ctrl+Enter | إدراج سطر أسفل |

### الكود

| الاختصار (Mac) | الاختصار (Win) | الوظيفة |
|----------------|----------------|---------|
| F2 | F2 | إعادة تسمية Symbol |
| F12 | F12 | الذهاب للتعريف |
| Shift+F12 | Shift+F12 | عرض كل المراجع |
| Cmd+. | Ctrl+. | Quick Fix / Code Actions |
| Cmd+Space | Ctrl+Space | Trigger Suggestions |

## إعداد Workspace للمشاريع

أنشئ ملف \`.vscode/settings.json\` في كل مشروع:

\`\`\`json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "typescript.tsdk": "node_modules/typescript/lib",
  "tailwindCSS.experimental.classRegex": [
    ["cva\\\\(([^)]*)\\\\)", "[\"']\`([^\"'\`]*).*?[\"'\`]"]
  ]
}
\`\`\`

وملف \`.vscode/extensions.json\` للإضافات الموصى بها:

\`\`\`json
{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode",
    "bradlc.vscode-tailwindcss",
    "github.copilot"
  ]
}
\`\`\`

## نصائح للإنتاجية

### 1. استخدم Snippets

أنشئ snippets مخصصة في \`Preferences: Configure User Snippets\`:

\`\`\`json
{
  "React Component": {
    "prefix": "rfc",
    "body": [
      "interface \${1:Component}Props {",
      "  $2",
      "}",
      "",
      "export function \${1:Component}({ $3 }: \${1:Component}Props) {",
      "  return (",
      "    <div>",
      "      $0",
      "    </div>",
      "  )",
      "}"
    ]
  }
}
\`\`\`

### 2. استخدم Multi-Cursor

- \`Cmd+Option+↑/↓\`: إضافة cursors
- \`Option+Click\`: إضافة cursor في مكان النقر
- \`Cmd+Shift+L\`: cursor على كل نسخة من الكلمة

### 3. استخدم الـ Integrated Terminal

- \`Cmd+\`\`: فتح الطرفية
- \`Cmd+Shift+[\` / \`]\`: التنقل بين terminals
- \`Cmd+\\\`: تقسيم الطرفية

### 4. استفد من Zen Mode

\`Cmd+K Z\` للدخول في وضع التركيز الكامل.

## الانتقال من VSCode لـ Cursor

إذا قررت الانتقال لـ Cursor:

1. **الإعدادات تنتقل تلقائياً** - Cursor يقرأ إعدادات VSCode
2. **الإضافات متوافقة** - معظم الإضافات تعمل
3. **الاختصارات نفسها** - لا حاجة لتعلم جديد

## الخلاصة

VSCode + الإعدادات الصحيحة + الإضافات المناسبة = آلة إنتاجية. المفاتيح:

1. **تخصيص المظهر** لراحة العين
2. **إضافات الذكاء الاصطناعي** لتسريع الكتابة
3. **إضافات اللغات** للفحص التلقائي
4. **حفظ الإعدادات** كـ Workspace settings

خذ وقتك في ضبط بيئتك. استثمار ساعة الآن سيوفر عليك عشرات الساعات لاحقاً!
        `,
      },
    ],
  },
  {
    name: "الأدوات المتقدمة (Advanced AI Tools)",
    articles: [
      {
        slug: "cursor-vs-windsurf",
        title: "مقارنة Cursor و Windsurf: دليل اختيار محرر الأكواد",
        section: "الأدوات المتقدمة",
        content: `
# مقارنة Cursor و Windsurf: دليل اختيار محرر الأكواد

في عصر البرمجة بالذكاء الاصطناعي، لم يعد VS Code التقليدي كافياً. ظهر جيل جديد من المحررات التي تدمج الذكاء الاصطناعي في صلب عملية التطوير. أبرز المتنافسين هما **Cursor** و **Windsurf**. دعنا نقارن بينهما لنساعدك في الاختيار.

## نظرة عامة سريعة

| الميزة | Cursor | Windsurf |
|--------|--------|----------|
| **النموذج الأساسي** | Claude 3.5 Sonnet / GPT-4o | Cascade (متعدد النماذج) |
| **فهم السياق** | قوي جداً (Codebase Indexing) | عميق جداً (Deep Context) |
| **السرعة** | سريع للغاية (Tab Autocomplete) | سلس وتفاعلي |
| **التسعير** | مجاني / 20$ شهرياً | مجاني / 20$ شهرياً |
| **التجربة** | تشعر وكأنك في VS Code محسّن | تجربة أكثر انسيابية وFlow |

## 1. Cursor: المحرر الذي غيّر قواعد اللعبة

Cursor هو "شوكة" (Fork) من VS Code، مما يعني أنه يدعم كل إضافاتك المفضلة، ولكنه مدمج مع ميزات AI قوية.

### أهم المميزات:
- **Composer (CMD+I)**: نافذة عائمة تتيح لك كتابة كود في ملفات متعددة دفعة واحدة. يمكنك أن تقول له "أنشئ صفحة جديدة مع مكوناتها"، وسيقوم بإنشاء الملفات وتعديل الروابط.
- **Tab Autocomplete**: إكمال تلقائي يتنبأ ليس فقط بالكلمة التالية، بل بأسطر كاملة وحتى تغييرات في أماكن متعددة.
- **Codebase Chat**: يمكنك سؤال الشات عن أي شيء في مشروعك: "أين يتم تعريف المتغير X؟" أو "كيف يعمل نظام المصادقة؟".

\`\`\`typescript
// مثال: كيف تطلب من Cursor تحسين دالة
// حدد الكود واضغط CMD+K
// البرومبت: "حسن الأداء وتأكد من معالجة الأخطاء"

async function fetchData(url: string) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error("Failed");
    return await res.json();
  } catch (error) {
    console.error(error);
    return null;
  }
}
\`\`\`

## 2. Windsurf: الموجة الجديدة من Codeium

Windsurf هو محرر جديد من فريق Codeium، يركز على "التدفق" (Flow) وفهم السياق العميق.

### أهم المميزات:
- **Cascade**: محرك ذكي يفهم "نواياك". إذا قمت بفتح ملف معين، يفهم Cascade أنك تريد العمل عليه ويجهز السياق المناسب.
- **Deep Context Awareness**: يتفوق أحياناً في فهم العلاقات المعقدة بين الملفات دون الحاجة لإضافتها يدوياً للسياق.
- **الأدوات المدمجة**: يمتلك قدرة قوية على تشغيل أوامر Terminal وفهم مخرجاتها لإصلاح الأخطاء تلقائياً.

## أيهما تختار؟

### اختر Cursor إذا كنت:
- تريد التحكم الدقيق في الملفات التي يتم تعديلها.
- تعتمد بشدة على ميزة Composer للتعديلات المتعددة.
- تريد تجربة أقرب ما تكون لـ VS Code الأصلي.

### اختر Windsurf إذا كنت:
- تفضل محرراً "يفهمك" دون الكثير من التوجيه.
- تحب الواجهات الأكثر حداثة وانسيابية.
- تريد تجربة مجانية قوية (Codeium يقدم خطة مجانية ممتازة).

## الخلاصة

كلاهما خياران رائعان وينقلانك من "محرر أكواد" إلى "بيئة تطوير ذكية". نصيحتنا في Vibe Coding: **جرب كليهما لمدة يوم واحد**. الحدس (الفايب) هو الحكم النهائي!
        `,
      },
    ],
  },
  {
    name: "أنماط البرمجة (Coding Patterns)",
    articles: [
      {
        slug: "conversational-coding",
        title: "البرمجة بالحوار: زميلك الذكي",
        section: "أنماط البرمجة",
        content: `
# البرمجة بالحوار (Conversational Coding)

البرمجة بالحوار هي نمط جديد من التطوير حيث لا تكون أنت الكاتب الوحيد للكود، بل تدخل في "حوار" مستمر مع الذكاء الاصطناعي لبناء وتحسين البرمجيات. إنه يشبه البرمجة الزوجية (Pair Programming) ولكن مع شريك فائق الذكاء، لا يكل، ومتاح 24/7.

## لماذا البرمجة بالحوار؟

في السابق، كنت تفكر في الحل، ثم تكتبه. الآن، المعادلة تغيرت:
1. **أنت تصف النية** (Intent).
2. **الذكاء الاصطناعي يقترح التنفيذ** (Implementation).
3. **أنت تراجع وتنقح** (Review & Refine).

هذا النمط يقلل من العبء المعرفي (Cognitive Load) ويسمح لك بالتركيز على "ماذا" بدلاً من "كيف".

## المبادئ الثلاثة للحوار الفعال

### 1. السياق هو الملك (Context is King)
الذكاء الاصطناعي ليس ساحراً؛ إنه محرك احتمالات. لكي يعطيك إجابة دقيقة، يجب أن تغذيه بالسياق المناسب.

**مثال سيء:**
"اكتب دالة لجلب البيانات."

**مثال جيد (Vibe Coding):**
"نحن نبني تطبيق Next.js 15 مع Supabase. اكتب دالة Server Action لجلب بيانات المستخدم الحالي، مع معالجة الأخطاء باستخدام try/catch وإرجاع نوع Result<User, Error>."

### 2. التكرار السريع (Iterative Refinement)
لا تتوقع الحل المثالي من أول محاولة. تعامل مع الأمر كلعبة تنس.

- **أنت:** "أنشئ واجهة لبطاقة منتج."
- **AI:** (يعطيك كوداً أساسياً)
- **أنت:** "جميل، لكن اجعل الصورة دائرية وأضف تأثير ظل عند التحويم."
- **AI:** (يعدل الكود)
- **أنت:** "الآن، اربط زر الشراء بـ useCart hook."

### 3. اطلب التفسير (Ask for Explanation)
لا تقبل الكود كما هو. استخدم الحوار للتعلم.

\`\`\`markdown
User: لماذا استخدمت useCallback هنا؟
AI: استخدمت useCallback لمنع إعادة إنشاء الدالة في كل تصيير (Render)، مما يحسن الأداء عند تمريرها لمكونات فرعية تعتمد على React.memo.
\`\`\`

## تقنيات متقدمة

### نمط "خطة أولاً" (Plan-First)
قبل كتابة أي كود، اطلب من الذكاء الاصطناعي وضع خطة.

"أريد بناء نظام تعليقات. ما هي الخطوات والملفات التي نحتاجها؟"

بعد الاتفاق على الخطة، ابدأ في تنفيذها خطوة بخطوة.

### نمط "المحامي ب" (Devil's Advocate)
اطلب من الذكاء الاصطناعي نقد كودك أو كوده.

"هل هناك ثغرات أمنية في هذا الكود؟"
"كيف يمكن تحسين أداء هذه الدالة؟"

## الخلاصة

البرمجة بالحوار ليست مجرد "كتابة أوامر". إنها مهارة تواصل. كلما كنت أفضل في شرح أفكارك وتقييم الردود، أصبحت "مبرمج إحساس" أفضل. تذكر: الذكاء الاصطناعي هو المساعد، وأنت القائد.
        `,
      },
    ],
  },
  {
    name: "حالات عملية (Real-World Case Studies)",
    articles: [
      {
        slug: "saas-in-a-week",
        title: "بناء SaaS من الصفر في أسبوع",
        section: "حالات عملية",
        content: `
# دراسة حالة: بناء SaaS من الصفر في أسبوع

هل يمكن بناء منتج برمجيات كخدمة (SaaS) كامل في أسبوع واحد؟ مع Vibe Coding، الإجابة هي نعم. في هذه الدراسة، سنستعرض كيف قمنا ببناء "FormVibe" - أداة لبناء النماذج - باستخدام Stack الحديث والذكاء الاصطناعي.

## اليوم 1: الفكرة والتصميم (The Spark)

بدلاً من قضاء أيام في Figma، استخدمنا **v0.dev** و **Claude** لتوليد واجهات المستخدم.

- **البرومبت:** "أريد صفحة هبوط لمنتج SaaS لبناء النماذج. نمط عصري، داكن، مع تدرجات لونية نيون."
- **النتيجة:** كود React/Tailwind جاهز للاستخدام في دقائق.

## اليوم 2: إعداد المشروع (The Setup)

استخدمنا **Next.js 15** مع **Supabase**.

\`\`\`bash
npx create-next-app@latest form-vibe
npm install @supabase/supabase-js
\`\`\`

طلبنا من **Cursor**: "قم بإعداد عميل Supabase وتكوين متغيرات البيئة. أنشئ ملفات الأنواع (Types) لقاعدة البيانات."

## اليوم 3: المصادقة وقاعدة البيانات (Backend Magic)

بدلاً من كتابة SQL يدوياً، طلبنا من الذكاء الاصطناعي:
"أنشئ مخطط SQL لجدول المستخدمين، النماذج، والإجابات. تأكد من تفعيل RLS (Row Level Security) بحيث لا يرى المستخدم إلا نماذجه."

النتيجة كانت ملف \`schema.sql\` جاهزاً للتنفيذ في Supabase Dashboard.

## اليوم 4: لوحة التحكم (The Dashboard)

بنينا لوحة التحكم باستخدام مكونات **Shadcn/ui**.
- الجدول: لعرض النماذج.
- النموذج: لإنشاء أسئلة جديدة.
- الرسوم البيانية: لعرض التحليلات (استخدمنا Recharts بمساعدة AI).

## اليوم 5: النماذج العامة (Public Facing)

الجزء الأصعب: كيف نعرض النموذج للمستخدم النهائي؟
استخدمنا صفحات Next.js الديناميكية \`app/f/[id]/page.tsx\`.

\`\`\`typescript
// طلبنا من AI:
// "اكتب مكوناً يعرض حقلاً بناءً على نوعه (نص، اختيار، تقييم)"
export function FieldRenderer({ field }) {
  switch (field.type) {
    case 'text': return <Input ... />;
    case 'select': return <Select ... />;
    // ...
  }
}
\`\`\`

## اليوم 6: الدفع والنشر (The Polish)

ربطنا **Stripe** للدفع.
البرومبت: "أنشئ Server Action لإنشاء جلسة دفع Stripe للمستخدم الحالي."

ثم النشر على **Vercel**.

## اليوم 7: الإطلاق والتسويق

استخدمنا ChatGPT لكتابة محتوى الإطلاق، تغريدات تويتر، ورسائل البريد الإلكتروني.

## الدروس المستفادة

1. **السرعة لا تعني الفوضى**: الذكاء الاصطناعي يساعدك في كتابة كود نظيف (مع TypeScript) أسرع مما تكتب كوداً فوضوياً بيدك.
2. **القرارات أهم من الكود**: قضينا وقتاً أكثر في تقرير "ماذا نبني" ووتاً أقل في "كيف نبنيه".
3. **التوقف عند العقبات**: عندما واجهنا خطأ غامضاً في Next.js، كان Perplexity هو المنقذ.

بناء SaaS لم يعد يتطلب فريقاً كاملاً. يتطلب فقط فكرة، "فايب" جيد، وأدوات ذكية.
        `,
      },
    ],
  },
  {
    name: "الأمان وأفضل الممارسات (Security & Best Practices)",
    articles: [
      {
        slug: "code-review-checklist",
        title: "قائمة مراجعة الكود المولَّد بالذكاء الاصطناعي",
        section: "الأمان وأفضل الممارسات",
        content: `
# قائمة مراجعة الكود المولَّد بالذكاء الاصطناعي

الذكاء الاصطناعي مبرمج بارع، لكنه قد يكون "واثقاً بشكل خاطئ" (Confidently Wrong). لا تقم أبداً بنسخ ولصق الكود (Copy-Paste) دون مراجعة. إليك قائمة التحقق الذهبية لضمان جودة وأمان الكود المولَّد.

## 1. الأمان (Security) 🛡️

- [ ] **المدخلات (Inputs)**: هل يتم التحقق من صحة بيانات المستخدم؟ تأكد من وجود \`zod\` أو آليات تحقق مشابهة.
- [ ] **حقن SQL/XSS**: هل الكود عرضة لهجمات الحقن؟ (مثلاً: استخدام استعلامات SQL خام بدلاً من ORM).
- [ ] **الأسرار (Secrets)**: هل قام الذكاء الاصطناعي بوضع مفاتيح API أو كلمات مرور مباشرة في الكود؟ (يجب أن تكون في \`.env\`).
- [ ] **الصلاحيات**: هل يتحقق الكود من أن المستخدم يملك الحق في تنفيذ هذا الإجراء؟

## 2. المنطق والصحة (Logic & Correctness) 🧠

- [ ] **حالات الحافة (Edge Cases)**: ماذا يحدث إذا كانت المصفوفة فارغة؟ ماذا لو كان المتغير \`null\`؟
- [ ] **الوهم (Hallucination)**: هل استخدم الذكاء الاصطناعي دالة أو مكتبة غير موجودة؟ (يحدث كثيراً!).
- [ ] **الحلقات اللانهائية**: تأكد من شروط الخروج في الحلقات (\`while\`, \`for\`) و \`useEffect\`.

## 3. الأداء (Performance) 🚀

- [ ] **N+1 Problem**: في استعلامات قاعدة البيانات، هل نجلب البيانات في حلقة تكرار؟
- [ ] **إعادة التصيير (Re-renders)**: هل هناك استخدام غير ضروري لـ \`useState\` أو تأثيرات جانبية ثقيلة؟
- [ ] **حجم الحزمة (Bundle Size)**: هل استورد مكتبة ضخمة لمجرد دالة بسيطة؟ (مثلاً استيراد \`lodash\` بالكامل).

## 4. الجودة والصيانة (Quality & Maintainability) 🧹

- [ ] **تسمية المتغيرات**: هل الأسماء واضحة ومعبرة؟ (تجنب \`x\`, \`data2\`).
- [ ] **التكرار (DRY)**: هل يمكن استخراج هذا المنطق في دالة مساعدة؟
- [ ] **الأنواع (Types)**: هل هناك استخدام مفرط لـ \`any\`؟ (في TypeScript).

## مثال عملي

**كود مولد (فيه مشاكل):**
\`\`\`javascript
function getUser(id) {
  const query = "SELECT * FROM users WHERE id = " + id; // ❌ SQL Injection risk
  return db.execute(query);
}
\`\`\`

**بعد المراجعة والتحسين:**
\`\`\`typescript
async function getUser(id: string) {
  // ✅ استخدام Parameterized Query
  const user = await db.users.findUnique({
    where: { id },
  });
  
  if (!user) throw new Error("User not found"); // ✅ معالجة الحالة الفارغة
  return user;
}
\`\`\`

## الخلاصة

تعامل مع كود الذكاء الاصطناعي كما تعامل كود متدرب جديد (Junior Developer) ذكي جداً ولكنه يفتقر للخبرة العملية. ثق، ولكن تحقق (Trust, but verify).
        `,
      },
    ],
  },
  {
    name: "المجتمع والموارد (Community & Resources)",
    articles: [
      {
        slug: "contribution-guide",
        title: "دليل المساهمة في Vibe Wiki",
        section: "المجتمع والموارد",
        content: `
# دليل المساهمة في Vibe Wiki

أهلاً بك في مجتمع Vibe Wiki! هذا المشروع مفتوح المصدر (Open Source) ونحن نؤمن بقوة المجتمع في بناء أفضل المصادر التعليمية العربية. مساهمتك، مهما كانت صغيرة، تصنع فرقاً.

## كيف يمكنك المساهمة؟

### 1. تحسين المحتوى 📝
- تصحيح الأخطاء الإملائية أو النحوية.
- تحديث المعلومات القديمة.
- إضافة أمثلة كود جديدة أو توضيحات إضافية.

### 2. إضافة مقالات جديدة 🚀
هل لديك خبرة في أداة معينة أو نمط برمجي؟ شارك معرفتك!
- تصفح قسم "المواضيع المقترحة" في Issues.
- اكتب مقالاً يتبع "أسلوب Vibe" (عملي، مباشر، وممتع).

### 3. التطوير التقني 💻
الموقع نفسه مبني بـ Next.js. يمكنك المساهمة في:
- تحسين واجهة المستخدم (UI/UX).
- إضافة ميزات جديدة (مثل الوضع الليلي، البحث المتقدم).
- تحسين الأداء وإمكانية الوصول (Accessibility).

## خطوات المساهمة (Workflow)

1. **Fork**: قم بعمل نسخة من المستودع على حسابك في GitHub.
2. **Clone**: حمل النسخة على جهازك.
   \`\`\`bash
   git clone https://github.com/YOUR-USERNAME/vibe-wiki.git
   \`\`\`
3. **Branch**: أنشئ فرعاً جديداً لمساهمتك.
   \`\`\`bash
   git checkout -b feature/new-article
   \`\`\`
4. **Edit**: قم بالتعديلات. تأكد من اتباع دليل التنسيق (Markdown).
5. **Commit**: احفظ تغييراتك برسالة واضحة.
   \`\`\`bash
   git commit -m "feat: add article about windsurf"
   \`\`\`
6. **Push**: ارفع التغييرات إلى حسابك.
   \`\`\`bash
   git push origin feature/new-article
   \`\`\`
7. **Pull Request (PR)**: اذهب للمستودع الأصلي وافتح PR. سنقوم بمراجعته ودمجه!

## قواعد السلوك (Code of Conduct)

- كن محترماً ولطيفاً. نحن هنا لنتعلم ونعلم.
- تقبل النقد البناء بصدر رحب.
- لا تنشر محتوى منسوخاً أو محمياً بحقوق نشر.

شكراً لأنك جزء من ثورة البرمجة العربية! 🌟
        `,
      },
    ],
  },
  {
    name: "الذكاء الاصطناعي المخصص (Custom AI)",
    articles: [
      {
        slug: "rag-systems",
        title: "أنظمة RAG: الاسترجاع المعزز بالتوليد",
        section: "الذكاء الاصطناعي المخصص",
        content: `
# أنظمة RAG: الاسترجاع المعزز بالتوليد (Retrieval-Augmented Generation)

النماذج اللغوية الكبيرة (LLMs) مثل GPT-4 ذكية، لكنها "مجمدة في الوقت" ولا تعرف شيئاً عن بياناتك الخاصة. هنا يأتي دور **RAG**. إنه الجسر الذي يربط ذكاء النموذج ببياناتك الحية.

## ما هو RAG ببساطة؟

تخيل RAG كطالب في امتحان (الـ LLM) ومعه كتاب مفتوح (بياناتك).
بدلاً من أن يحاول الطالب الإجابة من ذاكرته فقط (والتي قد تكون قديمة أو تخونه)، فإنه يبحث في الكتاب عن المعلومات ذات الصلة، ثم يصوغ الإجابة بناءً عليها.

**المعادلة:**
RAG = بحث دقيق (Retrieval) + توليد ذكي (Generation)

## كيف يعمل؟ (الخطوات الثلاث)

### 1. التضمين (Embedding) 🧮
تحويل النصوص (مستندات، رسائل بريد، كود) إلى أرقام (Vectors). الأرقام المتشابهة تعني معاني متشابهة.
- الأداة: OpenAI Embeddings API.

### 2. التخزين (Indexing) 🗄️
تخزين هذه الأرقام في "قاعدة بيانات المتجهات" (Vector Database).
- الأدوات: Pinecone, Weaviate, Supabase pgvector.

### 3. الاسترجاع والتوليد (Retrieval & Generation) 🔍
عندما يسأل المستخدم سؤالاً:
1. نحول سؤاله إلى أرقام (Vector).
2. نبحث في قاعدة البيانات عن النصوص الأكثر تشابهاً (Nearest Neighbors).
3. نأخذ هذه النصوص ونرفقها مع السؤال ونرسلها للنموذج (LLM).
4. النموذج يجيب بناءً على السياق المرفق.

## مثال بالكود (LangChain.js)

\`\`\`typescript
import { OpenAIEmbeddings } from "langchain/embeddings/openai";
import { MemoryVectorStore } from "langchain/vectorstores/memory";
import { RetrievalQAChain } from "langchain/chains";
import { ChatOpenAI } from "langchain/chat_models/openai";

// 1. تجهيز البيانات
const docs = [
  "Vibe Coding هو أسلوب برمجة يعتمد على الحدس والذكاء الاصطناعي.",
  "تم إطلاق Vibe Wiki في عام 2025."
];

// 2. إنشاء المخزن المتجهي
const vectorStore = await MemoryVectorStore.fromTexts(
  docs,
  [],
  new OpenAIEmbeddings()
);

// 3. إنشاء النموذج
const model = new ChatOpenAI({ modelName: "gpt-4" });

// 4. إنشاء السلسلة
const chain = RetrievalQAChain.fromLLM(
  model,
  vectorStore.asRetriever()
);

// 5. السؤال
const res = await chain.call({
  query: "متى تم إطلاق Vibe Wiki؟"
});

console.log(res.text); 
// النتيجة: تم إطلاق Vibe Wiki في عام 2025.
\`\`\`

## متى تستخدم RAG؟

- **خدمة العملاء**: بوت يجيب من دليل الاستخدام الخاص بالشركة.
- **البحث القانوني/الطبي**: البحث في آلاف المستندات وتلخيصها.
- **التحدث مع الكود**: سؤال الذكاء الاصطناعي عن مستودع كود ضخم.

RAG هو المفتاح لتحويل الـ AI من "لعبة مسلية" إلى "أداة عمل حقيقية" تعرف كل شيء عن عملك.
        `,
      },
    ],
  },
  {
    name: "مشاريع تطبيقية (Hands-On Projects)",
    articles: [
      {
        slug: "project-chatbot",
        title: "مشروع 1: بناء Chatbot ذكي",
        section: "مشاريع تطبيقية",
        content: `
# مشروع 1: بناء Chatbot ذكي للرد على الأسئلة

في هذا المشروع، سنبني بوت دردشة بسيط ولكنه قوي باستخدام **Vercel AI SDK**. سيتذكر البوت سياق المحادثة ويجيب بأسلوب "Vibe".

## المتطلبات
- Next.js 15
- Vercel AI SDK
- OpenAI API Key

## الخطوة 1: إعداد المشروع

\`\`\`bash
npx create-next-app@latest my-ai-bot
npm install ai openai
\`\`\`

أضف مفتاح API في \`.env.local\`:
\`\`\`
OPENAI_API_KEY=sk-...
\`\`\`

## الخطوة 2: إنشاء الـ API Route

أنشئ ملف \`app/api/chat/route.ts\`:

\`\`\`typescript
import { openai } from '@ai-sdk/openai';
import { streamText } from 'ai';

export const maxDuration = 30;

export async function POST(req: Request) {
  const { messages } = await req.json();

  const result = streamText({
    model: openai('gpt-4o'),
    messages,
    system: 'أنت مساعد برمجي ذكي يتبع فلسفة Vibe Coding. كن مختصراً ومباشراً.',
  });

  return result.toDataStreamResponse();
}
\`\`\`

## الخطوة 3: بناء الواجهة (UI)

في ملف \`app/page.tsx\`:

\`\`\`typescript
'use client';

import { useChat } from 'ai/react';

export default function Chat() {
  const { messages, input, handleInputChange, handleSubmit } = useChat();

  return (
    <div className="flex flex-col w-full max-w-md py-24 mx-auto stretch">
      {messages.map(m => (
        <div key={m.id} className="whitespace-pre-wrap mb-4">
          <span className="font-bold">{m.role === 'user' ? 'أنت: ' : 'Vibe Bot: '}</span>
          {m.content}
        </div>
      ))}

      <form onSubmit={handleSubmit} className="fixed bottom-0 w-full max-w-md p-2 bg-background">
        <input
          className="w-full p-2 border rounded shadow-xl text-black"
          value={input}
          onChange={handleInputChange}
          placeholder="اسألني أي شيء..."
        />
      </form>
    </div>
  );
}
\`\`\`

## الشرح

1. **Server-Side**: استخدمنا \`streamText\` من Vercel AI SDK. هذه الدالة تتصل بـ OpenAI وتعيد الرد "كلمة بكلمة" (Streaming)، مما يعطي تجربة مستخدم سريعة جداً.
2. **Client-Side**: الـ hook \`useChat\` هو السحر هنا. إنه يدير حالة الرسائل (messages)، المدخلات (input)، وحتى يرسل الطلب للـ API ويحدث الواجهة تلقائياً عند وصول الرد.

## التحدي القادم
حاول إضافة زر "مسح المحادثة" أو إمكانية تبديل النموذج بين GPT-4 و GPT-3.5 للحفاظ على التكلفة!
        `,
      },
    ],
  },
  {
    name: "أدوات الإنتاجية (Productivity Tools)",
    articles: [
      {
        slug: "vscode-setup",
        title: "إعداد VSCode المثالي للبرمجة بالإحساس",
        section: "أدوات الإنتاجية",
        content: `
# إعداد VSCode المثالي للبرمجة بالإحساس

محرر الأكواد هو سلاحك، ويجب أن يكون حاداً وجاهزاً. إليك كيفية تحويل VS Code إلى آلة إنتاجية تدعم "الفايب".

## 1. الثيم والخطوط (Look & Feel)

البرمجة بالإحساس تتطلب بيئة مريحة وجميلة.
- **الثيم**: جرب *Tokyo Night* أو *Catppuccin*. الألوان الداكنة والهادئة تساعد على التركيز.
- **الخط**: *Geist Mono* أو *JetBrains Mono* مع تفعيل الـ Ligatures.
- **الأيقونات**: *Material Icon Theme* لتسهيل تمييز الملفات.

\`\`\`json
// settings.json
{
  "editor.fontFamily": "'Geist Mono', monospace",
  "editor.fontLigatures": true,
  "workbench.colorTheme": "Tokyo Night",
  "editor.cursorBlinking": "smooth",
  "editor.cursorSmoothCaretAnimation": "on"
}
\`\`\`

## 2. إضافات الذكاء الاصطناعي (AI Extensions)

- **GitHub Copilot**: الأساسي. الإكمال التلقائي للكود.
- **Codeium**: بديل مجاني وسريع جداً.
- **Continue**: إضافة مفتوحة المصدر تتيح لك استخدام أي نموذج (Claude, Ollama) داخل VS Code مباشرة مع السياق.

## 3. إضافات لا غنى عنها

- **Prettier**: لتنسيق الكود تلقائياً عند الحفظ. "شكل الكود يؤثر على جودته".
- **ES7+ React Snippets**: اختصارات سريعة (مثل \`rafce\`) لإنشاء المكونات.
- **GitLens**: لمعرفة من كتب هذا الكود ومتى (Blame) وتاريخ الملف.
- **Error Lens**: يظهر لك الأخطاء بجانب السطر مباشرة بدلاً من التلميح الأحمر الصغير.

## 4. اختصارات لوحة المفاتيح (Keybindings)

السرعة تأتي من عدم رفع يدك عن الكيبورد.
- **CMD + P**: فتح أي ملف بسرعة (Quick Open).
- **CMD + Shift + F**: بحث في كامل المشروع.
- **CMD + /**: تعليق/إلغاء تعليق السطر.
- **CMD + D**: تحديد الكلمة التالية المطابقة (للتعديل المتعدد).

## نصيحة "الفايب"
قم بإخفاء الأشرطة الجانبية والسفلية (\`CMD + B\`, \`CMD + J\`) عندما تكون في "حالة التدفق". اجعل الشاشة للكود فقط. البساطة تولد التركيز.
        `,
      },
    ],
  },
];

export const allArticles: WikiArticle[] = wikiContent.flatMap(
  (section) => section.articles
);

export function getArticleBySlug(slug: string): WikiArticle | undefined {
  return allArticles.find((article) => article.slug === slug);
}

export function getAdjacentArticles(slug: string): {
  prev: WikiArticle | null;
  next: WikiArticle | null;
} {
  const index = allArticles.findIndex((article) => article.slug === slug);
  return {
    prev: index > 0 ? allArticles[index - 1] : null,
    next: index < allArticles.length - 1 ? allArticles[index + 1] : null,
  };
}
